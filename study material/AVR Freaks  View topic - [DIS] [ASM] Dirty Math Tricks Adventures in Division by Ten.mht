From: "Saved by Windows Internet Explorer 8"
Subject: AVR Freaks :: View topic - [DIS] [ASM] Dirty Math Tricks: Adventures in Division by Ten
Date: Thu, 24 Jun 2010 00:29:19 +0530
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_000D_01CB1334.48E2C780"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7600.16385

This is a multi-part message in MIME format.

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=37150&start=0

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" =
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" --><HTML=20
dir=3Dltr><HEAD><TITLE>AVR Freaks :: View topic - [DIS] [ASM] Dirty Math =
Tricks: Adventures in Division by Ten</TITLE>
<META content=3D"text/html; charset=3Dutf-8" http-equiv=3DContent-Type>
<META content=3Dtext/css http-equiv=3DContent-Style-Type>
<STYLE type=3Dtext/css>BODY {
	FONT-FAMILY: Verdana, Arial, Helvetica, sans-serif; LETTER-SPACING: =
1px; FONT-SIZE: 12px
}
.code {
	BORDER-BOTTOM: black 1px solid; BORDER-LEFT: black 1px solid; =
FONT-SIZE: 11px; BORDER-TOP: black 1px solid; BORDER-RIGHT: black 1px =
solid
}
.quote {
	BORDER-BOTTOM: black 1px solid; BORDER-LEFT: black 1px solid; =
FONT-SIZE: 11px; BORDER-TOP: black 1px solid; BORDER-RIGHT: black 1px =
solid
}
.php {
	BORDER-BOTTOM: black 1px solid; BORDER-LEFT: black 1px solid; =
FONT-SIZE: 11px; BORDER-TOP: black 1px solid; BORDER-RIGHT: black 1px =
solid
}
.Forum {
	FONT-SIZE: 18px; FONT-WEIGHT: bold
}
.Topic {
	FONT-SIZE: 14px; FONT-WEIGHT: bold
}
.genmed {
	FONT-SIZE: 12px
}
HR.sep {
	BORDER-BOTTOM: #d1d7dc 0px solid; BORDER-LEFT: #d1d7dc 0px solid; =
HEIGHT: 0px; BORDER-TOP: #d1d7dc 1px solid; BORDER-RIGHT: #d1d7dc 0px =
solid
}
</STYLE>

<META name=3DGENERATOR content=3D"MSHTML 8.00.7600.16490"></HEAD>
<BODY><SPAN class=3DForum>
<DIV align=3Dcenter>AVR Freaks</DIV></SPAN><BR><SPAN class=3DTopic>AVR =
Tutorials -=20
[DIS] [ASM] Dirty Math Tricks: Adventures in Division by Ten</SPAN><BR>
<HR>
<B>RetroDan</B> - Mar 31, 2006 - 10:00 AM<BR><B>Post subject: </B>[DIS] =
[ASM]=20
Dirty Math Tricks: Adventures in Division by Ten
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN's DIRTY MATH =
TRICKS</SPAN>=20
<BR><BR><SPAN style=3D"FONT-WEIGHT: bold">PURPOSE:</SPAN> On Going =
Tutorial on=20
Math Tricks in AVR Native Machine Language for Beginners. <BR><BR><SPAN=20
style=3D"FONT-WEIGHT: bold">PREAMBLE:</SPAN> While trying to help =
someone in=20
another FORUM with a Division-by-60 routine to converting seconds to =
minutes,=20
someone made the remark: <BR><BR><SPAN style=3D"FONT-WEIGHT: bold">
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR>What RetroDan has is a quick and dirty=20
approximation! </DIV></SPAN><BR><BR>I think it was meant as an insult, =
but it=20
gave me a great name for the type of binary routines I love: <SPAN=20
style=3D"FONT-WEIGHT: bold">Dirty Math!</SPAN> <BR><BR>Quick &amp; Dirty =
Routines=20
that are small and super fast. <BR><BR><SPAN style=3D"FONT-WEIGHT: =
bold">CAVEAT=20
LECTOR:</SPAN> If you don't like taking chances and experimenting and =
don't=20
really care about how big your programs are, or how fast they excecute =
then this=20
is not a place for you. May I recommend the Atmel Appnotes #200, 201 and =
204=20
that are chock full great standard math routines for the AVR =
microcontrollers.
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 10:08 AM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN's MATH TIPS</SPAN>=20
<BR><BR><SPAN style=3D"FONT-WEIGHT: bold">INTRODUCTION:</SPAN> =
<BR><BR>Here are a=20
few quick tips before we start: <BR><BR><SPAN style=3D"FONT-WEIGHT: =
bold">
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>DIRTY DAN'S TIP #1: ALWAYS USE A POWER OF TWO=20
</DIV></SPAN><BR><BR>If you are writing any program or routine, even if =
the=20
savings are not obvious at first, pick numbers that are powers-of-two. =
Somewhere=20
down the line you'll probably be glad you did. Make it a habit and your=20
microcontroller will thank you too. <BR><BR>For example: if you need to =
take an=20
average, don't take 10 readings and divide by 10, take 8 or 16. If =
you're=20
setting up a table, don't make entries 10 bytes long, make them 8 or 16. =
It will=20
greatly simplify things later. There's nothing magical about =
powers-of-ten to a=20
microprocessor. They're set up for powers-of-two and the number of =
fingers we=20
have means absolutely nothing to them. <BR><BR><BR><SPAN=20
style=3D"FONT-WEIGHT: bold">
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>DIRTY DAN'S TIP #2: AVOID DIVISION AT ALL =
COSTS!=20
</DIV></SPAN><BR><BR>While Addition, Subtraction and Multiplication can =
be done=20
in just a few clock cycles, most division involves looping and uses a =
lot of=20
processor time. Division is normally done by repeated subtractions, the=20
"standard" 16x16 division routine from the Atmel Appnotes averages over =
250=20
clocks cycles compare that to just 9 for a 16x16 multiply and just 2 for =
a 16x16=20
Addition. <BR><BR>One problem with high-level languages is that this =
dirty=20
little fact is kept hidden from the programer. So while you're happily =
writing=20
code that does Bilinear Interpolation or Cubic Splines, your processor =
is=20
swearing at you under his breath everytime you ask for a division. =
You're=20
wondering why things are grinding to a halt with smoke drifting up from =
the PCB.=20
<BR><BR><SPAN style=3D"FONT-WEIGHT: bold">
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>DIRTY DAN'S TIP #3: IF YOU MUST DIVIDE, DO IT =
BY POWERS=20
OF TWO! </DIV></SPAN><BR><BR>Division by a power of two can be easily =
and quick=20
accoplished with just a few right-shifts. Each time you shift your bits =
to the=20
right you are essentially dividing your number in half. So to divide by =
four you=20
just shift-right twice. <BR><BR><SPAN style=3D"FONT-WEIGHT: bold">
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>DIRTY DAN'S TIP #4: IF YOU MUST DIVIDE, DO IT =
ONLY ONCE!=20
</DIV></SPAN><BR><BR>If your equation has multiple divisions involved, =
try and=20
re-arrange your equation so you only divide once. <BR><BR>For example: =
if you=20
need to divide by 10 and later divide by 12, perhaps you can re-arrange =
things=20
and just divide once by 120 and be done with it.
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 11:20 AM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS:=20
DIVISION-BY-TEN</SPAN> <BR><BR><SPAN style=3D"FONT-WEIGHT: =
bold">PREAMBLE:</SPAN>=20
<BR><BR>I've been working on my own driver routines for the LCD Display =
on the=20
Butterfly (same as STK502) that are super small and fast. When it came =
time to=20
write a little routine that displays a number in decimal, rather than =
Hex, I ran=20
into my old nemesis DIVISION! <BR><BR>To be more precises, =
Division-by-Ten.=20
Since we humans are so fond of Division-by-Ten, I thought it would make =
an=20
excellent starting point for our examination of my Dirty Math Tricks.=20
<BR><BR>For this routine, all we want is to take a single byte value and =
display=20
it on the LCD Display in Decimal Number Form. So we need to take a =
number with a=20
maximum value of $FF and break it into three: 2 / 5 / 5. <BR><BR>The way =
most of=20
us humans would do this is to first divide by it by 100 and then by 10 =
and then=20
keep the remainder; <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>255 / 100 =3D 2&nbsp; &nbsp; =
&nbsp;(remainder of 55)=20
<BR>55&nbsp; / 10&nbsp; =3D 5 <BR>remainder =3D 5 <BR></DIV><BR><BR>Oh =
no, that=20
means we need to have two division routines! One for division by 100 and =
another=20
by ten. Mybe we should just use a general division routine and change =
the=20
divisor from 100 to 10 rather than have two routines. So I go and check =
the=20
Atmel Appnote 200 looking for a general 8x8 unsigned division routine =
and here=20
is what I found: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV=20
class=3Dcodecontent><BR>;************************************************=
***************************=20
<BR>;* "div8u" - 8/8 Bit Unsigned Division <BR>;* <BR>;* This subroutine =
divides=20
the two register variables "dd8u" (dividend) and <BR>;* "dv8u" =
(divisor). The=20
result is placed in "dres8u" and the remainder in <BR>;* "drem8u". =
<BR>;*&nbsp;=20
<BR>;* Number of words&nbsp; &nbsp;:14 <BR>;* Number of cycles&nbsp; =
&nbsp;:97=20
<BR>;* Low registers used&nbsp; &nbsp;:1 (drem8u) <BR>;* High registers=20
used&nbsp; :3 (dres8u/dd8u,dv8u,dcnt8u)=20
<BR>;********************************************************************=
*******=20
<BR><BR>.def&nbsp; &nbsp;drem8u&nbsp; &nbsp;=3Dr15&nbsp; &nbsp;&nbsp;=20
&nbsp;;remainder <BR>.def&nbsp; &nbsp;dres8u&nbsp; &nbsp;=3Dr16&nbsp; =
&nbsp;&nbsp;=20
&nbsp;;result <BR>.def&nbsp; &nbsp;dd8u&nbsp; &nbsp;=3Dr16&nbsp; =
&nbsp;&nbsp;=20
&nbsp;;dividend <BR>.def&nbsp; &nbsp;dv8u&nbsp; &nbsp;=3Dr17&nbsp; =
&nbsp;&nbsp;=20
&nbsp;;divisor <BR>.def&nbsp; &nbsp;dcnt8u&nbsp; &nbsp;=3Dr18&nbsp; =
&nbsp;&nbsp;=20
&nbsp;;loop counter <BR><BR>div8u:&nbsp; &nbsp;sub&nbsp;=20
&nbsp;drem8u,drem8u&nbsp; &nbsp;;clear remainder and carry <BR>&nbsp;=20
&nbsp;ldi&nbsp; &nbsp;dcnt8u,9&nbsp; &nbsp;;init loop counter =
<BR>d8u_1:&nbsp;=20
&nbsp;rol&nbsp; &nbsp;dd8u&nbsp; &nbsp;&nbsp; &nbsp;;shift left dividend =

<BR>&nbsp; &nbsp;dec&nbsp; &nbsp;dcnt8u&nbsp; &nbsp;&nbsp; =
&nbsp;;decrement=20
counter <BR>&nbsp; &nbsp;brne&nbsp; &nbsp;d8u_2&nbsp; &nbsp;&nbsp; =
&nbsp;;if=20
done <BR>&nbsp; &nbsp;ret&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;;&nbsp; =
&nbsp;=20
return <BR>d8u_2:&nbsp; &nbsp;rol&nbsp; &nbsp;drem8u&nbsp; &nbsp;&nbsp;=20
&nbsp;;shift dividend into remainder <BR>&nbsp; &nbsp;sub&nbsp;=20
&nbsp;drem8u,dv8u&nbsp; &nbsp;;remainder =3D remainder - divisor =
<BR>&nbsp;=20
&nbsp;brcc&nbsp; &nbsp;d8u_3&nbsp; &nbsp;&nbsp; &nbsp;;if result =
negative=20
<BR>&nbsp; &nbsp;add&nbsp; &nbsp;drem8u,dv8u&nbsp; &nbsp;;&nbsp; &nbsp; =
restore=20
remainder <BR>&nbsp; &nbsp;clc&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;;&nbsp;=20
&nbsp; clear carry to be shifted into result <BR>&nbsp; &nbsp;rjmp&nbsp; =

&nbsp;d8u_1&nbsp; &nbsp;&nbsp; &nbsp;;else <BR>d8u_3:&nbsp; =
&nbsp;sec&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;;&nbsp; &nbsp; set carry to be shifted =
into=20
result <BR>&nbsp; &nbsp;rjmp&nbsp; &nbsp;d8u_1 <BR></DIV><BR><BR>Only 14 =
program=20
steps is not bad. Almost 100 clock cycles per call and we need to call =
it twice=20
fort a single byte conversion. That's about 200 clock cycles each. I'm =
sure we=20
can do better than that...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 11:54 AM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued)</SPAN> <BR><BR>Previously we divided our 1 byte number by =
100 then=20
by 10 and when it comes time to expand our routine to handle 16 bit =
numbers=20
we'll need to divide by 10,000, 1,000, 100 and finally by 10. At approx. =
100=20
cycles per call that's 400 clock cycles per number. <BR><BR>Maybe we =
should look=20
at the problem again from the "other side" the right-hand-side instead =
of left.=20
<BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>255 / 10 =3D 25&nbsp; &nbsp;Remainder =3D 5 =
<BR>25&nbsp; / 10=20
=3D 2&nbsp; &nbsp; Remainder =3D 5 <BR>2&nbsp; &nbsp;/ 10 =3D 0&nbsp; =
&nbsp; Remainder=20
=3D 2 </DIV><BR><BR>Well we've managed to extract the 255 again, but now =
we need=20
Three calls to the division routine and for a 16 byte number we'll need =
Five.=20
The only thing we have going for us using this method is that if we can =
find a=20
"special" division routine for Division-by-Ten that is smaller and/or =
faster=20
than the Atmel routine, we might have something we can work with...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 12:16 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued)</SPAN> <BR><BR>I remember someone posting a file of=20
Division-by-a-Constant Routines, so why don't we see if we can get luck =
there.=20
<BR><BR>Here is what I found, exactly what we're looking for, a =
specialized=20
routine for Division-by-Ten: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV=20
class=3Dcodecontent><BR>;************************************************=
***************************=20
<BR>;* Function "Div16_10" <BR>;* Divides an unsigned 16 bit word =
(XH:XL) by 10=20
<BR>;* Returns quotient in YH:YL and remainder in XL <BR>;* <BR>;* =
Author:=20
Andreas Lenze (andreas.lenze@t-online.de) <BR>;* Equations by D: W. =
Jones:=20
<BR>;* <BR>;*&nbsp; &nbsp;Reciprocal mul w. extra precision: =
<BR>;*&nbsp;=20
&nbsp;unsigned int A; <BR>;*&nbsp; &nbsp;unsigned int scaled_reciprocal =
=3D=20
0xCCCD; <BR>;*&nbsp; &nbsp;unsigned int Q; /* the quotient */ <BR>;*=20
<BR>;*&nbsp; &nbsp;Q =3D ((A * 0xCCCD) &gt;&gt; 19) <BR>;*&nbsp; &nbsp; =
<BR>;*=20
Uses: high regs: 7 (r17, r18, r19, X, Y) <BR>;*&nbsp; &nbsp; low =
regs:&nbsp; 3=20
(r0, r1, r2) <BR>;* <BR>;*&nbsp; &nbsp; words:&nbsp; &nbsp; &nbsp;36 (w. =

push/pop =3D 8 words) <BR>;*&nbsp; &nbsp; cycles:&nbsp; &nbsp; 46 (w. =
push/pop =3D=20
16 cycles) <BR>;* <BR>;* Note: Hardware multiplier required ("mul" =
instruction)=20
<BR>;*=20
<BR>;********************************************************************=
*******=20
<BR><BR>Div16_10: <BR>&nbsp; &nbsp;push&nbsp; &nbsp;r2 <BR>&nbsp;=20
&nbsp;push&nbsp; &nbsp;r19 <BR>&nbsp; &nbsp;push&nbsp; &nbsp;r18 =
<BR>&nbsp;=20
&nbsp;push&nbsp; &nbsp;r17 <BR><BR>&nbsp; &nbsp;ldi&nbsp; =
&nbsp;YH,0xCC&nbsp;=20
&nbsp;&nbsp; &nbsp;; scaled reciprocal for /10 <BR>&nbsp; =
&nbsp;ldi&nbsp;=20
&nbsp;YL,0xCD <BR><BR>&nbsp; &nbsp;; Q =3D A * 0xCCCD <BR>&nbsp; &nbsp;; =

(r19:r18:r17[:rXX] =3D XH:XL * YH:YL) <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
clr&nbsp;=20
&nbsp; &nbsp;r2 <BR>&nbsp; &nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; =
&nbsp;XH,=20
YH&nbsp; &nbsp;&nbsp; &nbsp;; ah * bh <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
movw&nbsp;=20
&nbsp; r19:r18, r1:r0 <BR>&nbsp; &nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; =
&nbsp;XL,=20
YL&nbsp; &nbsp;&nbsp; &nbsp;; al * bl <BR>&nbsp; &nbsp;mov&nbsp;=20
&nbsp;r17,r1&nbsp; &nbsp;&nbsp; &nbsp;; r0 to [rXX] is superfluous =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; &nbsp;XH, YL&nbsp; &nbsp;&nbsp; =
&nbsp;; ah=20
* bl <BR>&nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;r17, r0 =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp; &nbsp;r18, r1 <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp; adc&nbsp; &nbsp; &nbsp;r19, r2 <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
mul&nbsp;=20
&nbsp; &nbsp;YH, XL&nbsp; &nbsp;&nbsp; &nbsp;; bh * al <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp; add&nbsp; &nbsp; &nbsp;r17, r0 <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
adc&nbsp;=20
&nbsp; &nbsp;r18, r1 <BR>&nbsp; &nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp; =
&nbsp;r19,=20
r2 <BR><BR>&nbsp; &nbsp;; Q =3D Q &gt;&gt; 16: use r19:r18 as word =
<BR>&nbsp;=20
&nbsp;; Q =3D Q &gt;&gt; 3 <BR>&nbsp; &nbsp;lsr&nbsp; &nbsp;r19&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; do the last 3 shifts <BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 =
<BR>&nbsp;=20
&nbsp;lsr&nbsp; &nbsp;r19 <BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 =
<BR>&nbsp;=20
&nbsp;lsr&nbsp; &nbsp;r19 <BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 =
<BR><BR>&nbsp;=20
&nbsp;; r19:r18 now "Q" (=3D result &gt;&gt; 19) <BR>&nbsp; &nbsp;; R =
=3D A - 10*Q;=20
<BR>&nbsp; &nbsp;ldi&nbsp; &nbsp;r17,10&nbsp; &nbsp;&nbsp; &nbsp;; =
multiply=20
r19:r18 by 10 <BR>&nbsp; &nbsp;mul&nbsp; &nbsp; &nbsp;r18, r17&nbsp; =
&nbsp;; al=20
* bl <BR>&nbsp; &nbsp;sub&nbsp; &nbsp;XL,r0 <BR>&nbsp; &nbsp;clr&nbsp; =
&nbsp;XH=20
<BR>&nbsp; &nbsp;movw&nbsp; &nbsp;YL,r18&nbsp; &nbsp;&nbsp; &nbsp;; make =
copy of=20
Q <BR><BR>&nbsp; &nbsp;; XL holds "R" <BR>&nbsp; &nbsp;; YH:YL holds "Q" =

<BR>&nbsp; &nbsp;pop&nbsp; &nbsp;r17 <BR>&nbsp; &nbsp;pop&nbsp; =
&nbsp;r18=20
<BR>&nbsp; &nbsp;pop&nbsp; &nbsp;r19 <BR>&nbsp; &nbsp;pop&nbsp; &nbsp;r2 =

<BR><BR>&nbsp; &nbsp;ret <BR></DIV><BR><BR>Wow, I looks huge! Let's see =
46=20
program steps, that's a little on the heavy side, and 10 registers used =
ouch!.=20
However, it is a 16 bit Divide-by-Ten Routine and it excecutes in about =
1/2 the=20
time that the Atmel 8 bit routine did, so we're moving in the right =
direction.=20
Two or Three calls to this would be 100 to 150 cycles versus the 200 to =
300=20
using the Atmel Routine. <BR><BR>If we can't come up with something on =
our own,=20
perhaps we could strip this down to an 8 bit routine, or perhaps just =
bite the=20
bullet because sooner-or-later we're gonna' need to convert 16 bit =
values=20
anyway...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 12:34 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued) </SPAN><BR><BR>A while back, while literally =
sitting-on-the-throne,=20
I happened to realized that 255 is evenly divisable by 5 and that it is =
only one=20
away from 256 which is a Power-of-Two. After a while, it becomes a habit =
to=20
always be on-the-lookout for Powers-of-Two. Either that or I'm slowly =
drifting=20
into the world of padded-rooms and nice doctors in white smocks. Of all =
the=20
things I've lost, I miss my mind the most. <BR><BR>To divide by Ten we =
might be=20
able to first Divide-by-Five then Right-Shift to Divide-by-Two and the =
result=20
would be a Division-by-Ten. I stored that fact away and wondered if the =
255-256=20
link could be put to use sometime. <BR><BR>Pehaps today is a good day to =
drag it=20
out of the bottom drawer and dust it off... <BR><BR>Let's see: 255 =
divided by 5=20
is 51 and 255 is awlful close to 256 and furthermore division by 256 is=20
super-super easy and requires ZERO program steps. The "Dirty Trick" to =
that is=20
to simply ignore the least significant Byte and we've essentially =
Divided our=20
number by 256. <BR><BR>Since 255 is almost equal to 256, then 255/256 is =
almost=20
equal to 1 <BR><BR>Since multiplication by one does not change a value =
<BR>Then=20
1/5 times 255/256 shoud be pretty close to 1/5 <BR><BR>Since division by =
256 can=20
be accomplished with the Dirty Math Trick of ignoring the lowest byte, =
we'll=20
leave that to last and our equation becomes: <BR><BR>1/5 time 255 and =
later=20
we'll truncate the lower byte. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>1/5 x 255 =3D 255 / 5 =3D 51 =
<BR></DIV><BR>So=20
mathematically speaking if we multiply our number by 51 and later =
<BR>ignore the=20
lower byte, we should get a pretty good approximation of =
<BR>Division-by-Five.=20
That's where our first routine will start...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 01:29 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued) </SPAN><BR><BR>Let's start by writing a routine that =
muliplies by 51=20
and we'll look at the high byte and see if our mathematical assumptions =
were=20
correct. <BR><BR>Here is the code: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV5: LDI B,51 <BR>&nbsp; &nbsp; &nbsp; MUL =
A,B&nbsp;=20
;ANSWER LEFT IN R1 <BR>&nbsp; &nbsp; &nbsp; RET <BR></DIV><BR><BR>Great =
it's=20
only 3 lines long!!! Let's test it's accuracy. <BR>We're interested in a =
single=20
byte so values can go from zero to 255 <BR>so lets check a few numbers =
in that=20
range and see how it performs: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp;10 =3D&gt;&nbsp; 1 (off by -1) =
<BR>&nbsp;50=20
=3D&gt;&nbsp; 9 (off by -1) <BR>100 =3D&gt; 19 (off by -1) <BR>150 =
=3D&gt; 29 (off by=20
-1) <BR>200 =3D&gt; 39 (off by -1) <BR>250 =3D&gt; 49 (off by -1) =
<BR></DIV><BR>Hmm,=20
we're alway off by minus one, so if we add one, we should be right on =
the money!=20
<BR><BR>So the new Division-by-Five Routine becomes: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV5: LDI B,51 <BR>&nbsp; &nbsp; &nbsp; MUL =
A,B=20
<BR>&nbsp; &nbsp; &nbsp; INC R1 ; ANSWER IN R1 <BR>&nbsp; &nbsp; &nbsp; =
RET=20
<BR></DIV><BR><BR>So we're half-way-home, all we need to do now is =
divide our=20
answer by two and we should have a "Quick and Dirty" Divide-by-Ten =
Routine...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 01:30 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued) </SPAN><BR><BR>There's two ways we can use our =
Division-by-Five=20
Routine for a Division-by-Ten Routine. <BR><BR>We can modify the DIV5 =
routine.=20
Earlier I stated that a "Quick and Dirty" way to Divide-by-Two is to =
just Shift=20
your bits to the right. This is how we modify our DIV5 Routine to get a =
DIV10:=20
<BR><BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV10: LDI B,51 <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;MUL=20
A,B <BR>&nbsp; &nbsp; &nbsp; &nbsp;INC R1&nbsp; &nbsp;;R1=3DA/5 =
<BR>&nbsp; &nbsp;=20
&nbsp; &nbsp;LSR A&nbsp; &nbsp; ;R1=3D(A/5)/2 =3D A/10 <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp;RET </DIV><BR><BR><BR>The other way we could have accomplished the =
same=20
thing would be to have the DIV10 routine call the DIV5 routine and that =
way we=20
"kill-two-birds-with-one-stone" because we get two usable routines from =
it:=20
<BR><BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV10: RCALL DIV5&nbsp; ;R1=3DA / 5 =
<BR>&nbsp; &nbsp;=20
&nbsp; &nbsp;LSR R1&nbsp; &nbsp; &nbsp; ;R1=3D(A/5) / 2 =3D A/10 =
<BR>&nbsp; &nbsp;=20
&nbsp; &nbsp;RET <BR><BR>DIV5:&nbsp; LDI B,51 <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;MUL=20
A,B <BR>&nbsp; &nbsp; &nbsp; &nbsp;INC R1&nbsp; &nbsp; &nbsp; ;ANSWER IN =
R1=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;RET </DIV><BR><BR>Just to be =
on-the-safe-side=20
let's double check the accuracy of these routines: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>&nbsp;10 =3D&gt;&nbsp; 1 Correct! <BR>&nbsp;50 =
=3D&gt;&nbsp;=20
5 Correct! <BR>100 =3D&gt; 10 Correct! <BR>150 =3D&gt; 15 Correct! =
<BR>200 =3D&gt; 20=20
Correct! <BR>250 =3D&gt; 25 Correct! </DIV><BR>So we did it. We have our =
first=20
"Dirty Math" Routine that is 100% accurate over the range we need. =
<BR>Stay=20
tuned however, there's still more to this story...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 01:48 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued) </SPAN><BR><BR><SPAN style=3D"FONT-WEIGHT: =
bold">PRE-SUMMARY:</SPAN>=20
<BR><BR>Not bad for a days work eh? We took a rather large routine that =
we=20
needed and reduced it to a "Quick and Dirty" little routine using a few =
"Dirty=20
Math Tricks". <BR><BR>Let's compare and see how well we did. <BR>First =
let's=20
compare to the Atmel 8x8 Unsigned Division Routine: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp;DIV10a&nbsp; &nbsp;DIV10b&nbsp; &nbsp;ATMEL =
<BR>REGISTERS:&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;2&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; =
&nbsp;=20
&nbsp; 4 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; &nbsp; -2&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-2&nbsp; &nbsp; &nbsp; &nbsp; - <BR>&nbsp; PERCENT:&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-50%&nbsp; &nbsp; &nbsp;-50%&nbsp; &nbsp; &nbsp; &nbsp;- =
<BR><BR>PROGRAM=20
WORDS:&nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7&nbsp; &nbsp; =
&nbsp;=20
&nbsp;15(incl RET) <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; -10&nbsp; &nbsp; =
&nbsp;=20
&nbsp; -8&nbsp; &nbsp; &nbsp; &nbsp; - <BR>&nbsp; PERCENT:&nbsp; &nbsp; =
&nbsp;=20
-66%&nbsp; &nbsp; &nbsp; -53%&nbsp; &nbsp; &nbsp; &nbsp;-=20
<BR><BR>SPEED/CYCLES:&nbsp; &nbsp; &nbsp;5&nbsp; &nbsp; &nbsp; &nbsp;=20
&nbsp;8&nbsp; &nbsp; &nbsp; &nbsp;97 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp;=20
-92&nbsp; &nbsp; &nbsp; &nbsp;-89 <BR>&nbsp; PERCENT:&nbsp; &nbsp; =
&nbsp;=20
-95%&nbsp; &nbsp; &nbsp; -92% <BR></DIV><BR>So we've used 1/2 the =
register=20
space, about 60% less program space and we're running at about 20 times =
the=20
speed that the Atmel Routine does. <BR><BR>Let compare to the =
Lenze/Jones=20
Routine: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp;DIV10a&nbsp; &nbsp;DIV10b&nbsp; &nbsp;LENZE =
<BR>REGISTERS:&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;2&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; =
&nbsp;=20
&nbsp;10 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; &nbsp; -8&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-8&nbsp; &nbsp; &nbsp; &nbsp; - <BR>&nbsp; PERCENT:&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-80%&nbsp; &nbsp; &nbsp;-80%&nbsp; &nbsp; &nbsp; &nbsp;- =
<BR><BR>PROGRAM=20
WORDS:&nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7&nbsp; &nbsp; =
&nbsp;=20
&nbsp;36 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; -31&nbsp; &nbsp; &nbsp; =
&nbsp;=20
-29&nbsp; &nbsp; &nbsp; &nbsp;- <BR>&nbsp; PERCENT:&nbsp; &nbsp; &nbsp;=20
-86%&nbsp; &nbsp; &nbsp; &nbsp;-80%&nbsp; &nbsp; &nbsp; -=20
<BR><BR>SPEED/CYCLES:&nbsp; &nbsp; &nbsp;5&nbsp; &nbsp; &nbsp; &nbsp;=20
&nbsp;8&nbsp; &nbsp; &nbsp; &nbsp;46 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp;=20
-41&nbsp; &nbsp; &nbsp; &nbsp;-38&nbsp; &nbsp; &nbsp; &nbsp; - =
<BR>&nbsp;=20
PERCENT:&nbsp; &nbsp; &nbsp; -89%&nbsp; &nbsp; &nbsp; -83%&nbsp; &nbsp; =
&nbsp;=20
&nbsp;- <BR></DIV><BR><BR>Against the Lenze/Jones routine we're using =
80% less=20
Register Space, about 85% less Program Space and w'e're running at =
between 6 to=20
10 times the speed. <BR><BR>Many might think that this is a great =
accomplishment=20
and that I should stop at this point. Especially those that probably =
would have=20
just used the larger routines and not had a second thought about it.=20
<BR><BR>Well, obviously some of you don't know me very well. <BR>I think =
I can=20
pull a few more "Dirty Tricks" from out of my hat and turn this Dirty =
Littlle=20
Routine into something totally scandalous. I'm not happy until the =
routine is so=20
small that it pulls numbers from thin air, like magick...
<HR>
 <B>RetroDan</B> - Mar 31, 2006 - 02:37 PM<BR><B>Post subject: </B>RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Continued) </SPAN><BR><BR>Let's re-examine what it is we're doing=20
mathematically with our Dirty Little DIV10 Routine: <BR><BR>We're =
multiplying by=20
51, adding one, then dividing by two, and then truncating to get a final =

division of 256: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>A / 5 ~=3D [ [ ( A x 51 ) + 1 ] / 2 ] / 256 =

<BR></DIV><BR><BR>Let's ignore that final division by 256 because it's=20
accomplished with ZERO program steps by ignoring the lower byte and =
there's no=20
way we can improve on that unless there are opcodes that can move us =
backwards=20
in time. <BR><BR>So we want to look closely at the right side of this =
equation:=20
<BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>256 x [A / 5] ~=3D ( 51A + 1) / 2 <BR>256 x =
[A / 5] ~=3D=20
51A/2 + 1/2 <BR></DIV><BR><BR>Well 1/2 doesn't really mean much to a=20
microprocessor, you either have a bit that is on or its off. We'll =
ignore it for=20
now and if need be, we'll increment something in the end like we did =
with our=20
DIV5 routine. <BR><BR>So now we have: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>256 x [A / 5] ~=3D 51A/2 <BR>256 x [A / 5] =
~=3D 25.5 x A=20
<BR>256 x [A / 5] ~=3D 25A <BR></DIV><BR><BR>Since we dropped a 1/2 =
earlier and=20
now we're stuck with another 0.5 perhaps we should round the 25.5 upto =
26 rather=20
than truncate it down to 25. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>256 x [A / 5] ~=3D 25.5 x A <BR>256 x [A / =
5] ~=3D 26A=20
<BR></DIV><BR>So to divide by 10 all we need to do is multiply by 26 and =
ignore=20
lower byte: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>MUL10: LDI B,26 <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;MUL=20
A,B&nbsp; &nbsp;;ANSWER IN R1 <BR></DIV><BR><BR>It sounds incredable, =
but let's=20
check the results and see what our error ratio is: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp;10 =3D&gt;&nbsp; 1&nbsp; Correct! =
<BR>&nbsp;50=20
=3D&gt;&nbsp; 5&nbsp; Correct! <BR>100 =3D&gt; 10&nbsp; Correct! <BR>150 =
=3D&gt;=20
15&nbsp; Correct! <BR>200 =3D&gt; 20&nbsp; Correct! <BR>250 =3D&gt; =
25&nbsp;=20
Correct! <BR></DIV><BR><BR>So it's 100% accurate over the range we need =
and it's=20
only two program lines. <BR><BR>We started with rather large routines =
requiring=20
50 to 100 clock cycles per call and have something that runs in just =
three.=20
<BR><BR>Can we reduce it even more? <BR><BR>Not really, not until Atmel =
comes=20
out with a MULI command that allows us to multiply a register with an =
immedaite=20
value rather than loading it into another register first. <BR><BR>Maybe =
next=20
year... <BR><BR>It would probably look like this: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV10: MULI A,26&nbsp; ;ANSWER IN R1 =
<BR></DIV>
<HR>
<B>RetroDan</B> - Mar 31, 2006 - 03:38 PM<BR><B>Post subject: </B>RE: =
[DIS][ASM]=20
Dirty Math Tricks
<HR class=3Dsep>
 <SPAN style=3D"FONT-WEIGHT: bold">TITLE: DIRTY DAN"s MATH TRICKS: =
DIVISION-BY-TEN=20
(Conclusion) </SPAN><BR><BR><SPAN style=3D"FONT-WEIGHT: bold">IN=20
CONCLUSION:</SPAN> <BR><BR>By systematically applying a few Dirty Tricks =
and=20
following our instincts combined with a little high-school math, we took =
some=20
rather large routines and reduced them down into just a couple program =
steps.=20
Something that many would say is impossible., but never say never my =
friend. If=20
I can do it, so can you! <BR><BR><SPAN style=3D"FONT-WEIGHT: =
bold">REQUEST FOR=20
FEED BACK:</SPAN> <BR><BR>I hope you found this posting entertaining as =
well as=20
educational. <BR><BR>If you would like to see more like it, please be =
sure to=20
let the moderators know. <BR><BR>Thank you for your time and =
consideration.
<HR>
 <B>alenze</B> - Mar 31, 2006 - 09:01 PM<BR><B>Post subject: </B>RE: =
[DIS][ASM]=20
Dirty Math Tricks
<HR class=3Dsep>
=20
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>MUL10: LDI B,26 <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;MUL=20
A,B&nbsp; &nbsp;;ANSWER IN R1 <BR></DIV><BR><BR>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR>So it's 100% accurate over the range we =
need and=20
it's only two program lines. <BR></DIV><BR><BR>This is not true. For a =
'div by=20
10' this is an approximation which will not yield correct results for =
all=20
integers between 1 and 255 decimal (try for example 169, 159 ... for 'A' =
to see=20
it fail). The 'scaled reciprocal' for a <SPAN=20
style=3D"FONT-WEIGHT: bold">correct</SPAN> 'division by 10' of an 8 bit =
integer=20
would have to be at least 9 bits to reach the required precision. =
<BR>Please=20
check out the mathematical basics for this technique at <A =
class=3Dpostlink=20
href=3D"http://www.cs.uiowa.edu/~jones/bcd/divide.html"=20
target=3D_blank>http://www.cs.uiowa.edu/~jones/bcd/divide.html</A> =
<BR><BR>The=20
claims in your comparison <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp;DIV10a&nbsp; &nbsp;DIV10b&nbsp; &nbsp;LENZE =
<BR>REGISTERS:&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;2&nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp; &nbsp; =
&nbsp;=20
&nbsp;10 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; &nbsp; -8&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-8&nbsp; &nbsp; &nbsp; &nbsp; - <BR>&nbsp; PERCENT:&nbsp; &nbsp; =
&nbsp;=20
&nbsp;-80%&nbsp; &nbsp; &nbsp;-80%&nbsp; &nbsp; &nbsp; &nbsp;- =
<BR><BR>PROGRAM=20
WORDS:&nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7&nbsp; &nbsp; =
&nbsp;=20
&nbsp;36 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp; -31&nbsp; &nbsp; &nbsp; =
&nbsp;=20
-29&nbsp; &nbsp; &nbsp; &nbsp;- <BR>&nbsp; PERCENT:&nbsp; &nbsp; &nbsp;=20
-86%&nbsp; &nbsp; &nbsp; &nbsp;-80%&nbsp; &nbsp; &nbsp; -=20
<BR><BR>SPEED/CYCLES:&nbsp; &nbsp; &nbsp;5&nbsp; &nbsp; &nbsp; &nbsp;=20
&nbsp;8&nbsp; &nbsp; &nbsp; &nbsp;46 <BR>&nbsp;DIFFERENCE:&nbsp; &nbsp;=20
-41&nbsp; &nbsp; &nbsp; &nbsp;-38&nbsp; &nbsp; &nbsp; &nbsp; - =
<BR>&nbsp;=20
PERCENT:&nbsp; &nbsp; &nbsp; -89%&nbsp; &nbsp; &nbsp; -83%&nbsp; &nbsp; =
&nbsp;=20
&nbsp;- <BR></DIV><BR><BR>are also incorrect: the '46 cycles' for =
'Lenze' is=20
including register saves (push/pop), the naked division routine w/o reg =
saves=20
and getting the remainder is: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>&nbsp; &nbsp;ldi&nbsp; &nbsp;YH,0xCC&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; scaled reciprocal for /10 <BR>&nbsp; &nbsp;ldi&nbsp; =
&nbsp;YL,0xCD=20
<BR><BR>&nbsp; &nbsp;; Q =3D A * 0xCCCD <BR>&nbsp; &nbsp;; =
(r19:r18:r17[:rXX] =3D=20
XH:XL * YH:YL) <BR>&nbsp; &nbsp; &nbsp; &nbsp; clr&nbsp; &nbsp; &nbsp;r2 =

<BR>&nbsp; &nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; &nbsp;XH, YH&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; ah * bh <BR>&nbsp; &nbsp; &nbsp; &nbsp; movw&nbsp; &nbsp; =
r19:r18, r1:r0=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; &nbsp;XL, YL&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; al * bl <BR>&nbsp; &nbsp;mov&nbsp; &nbsp;r17,r1&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; r0 to [rXX] is superfluous <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
mul&nbsp;=20
&nbsp; &nbsp;XH, YL&nbsp; &nbsp;&nbsp; &nbsp;; ah * bl <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp; add&nbsp; &nbsp; &nbsp;r17, r0 <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
adc&nbsp;=20
&nbsp; &nbsp;r18, r1 <BR>&nbsp; &nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp; =
&nbsp;r19,=20
r2 <BR>&nbsp; &nbsp; &nbsp; &nbsp; mul&nbsp; &nbsp; &nbsp;YH, XL&nbsp;=20
&nbsp;&nbsp; &nbsp;; bh * al <BR>&nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; =
&nbsp;=20
&nbsp;r17, r0 <BR>&nbsp; &nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp; =
&nbsp;r18, r1=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp; &nbsp;r19, r2 =
<BR><BR>&nbsp;=20
&nbsp;; Q =3D Q &gt;&gt; 16: use r19:r18 as word <BR>&nbsp; &nbsp;; Q =
=3D Q &gt;&gt;=20
3 <BR>&nbsp; &nbsp;lsr&nbsp; &nbsp;r19&nbsp; &nbsp;&nbsp; &nbsp;; do the =
last 3=20
shifts <BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 <BR>&nbsp; &nbsp;lsr&nbsp; =
&nbsp;r19=20
<BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 <BR>&nbsp; &nbsp;lsr&nbsp; =
&nbsp;r19=20
<BR>&nbsp; &nbsp;ror&nbsp; &nbsp;r18 <BR><BR>&nbsp; &nbsp;; r19:r18 now =
"Q" (=3D=20
result &gt;&gt; 19) <BR></DIV><BR><BR>That's 25 cycles for a 'divide 16 =
bit=20
number by 10' (result BTW is always correct over the full range 1 - =
65535).
<HR>
 <B>lfmorrison</B> - Mar 31, 2006 - 09:37 PM<BR><B>Post subject: </B>RE: =

[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Well now, Andreas... The argument could be made that RetroDan's =
solution is=20
*more correct* than the traditional integer approach. <BR><BR>169/10 =3D =
16 if we=20
follow traditional definitions. <BR><BR>Of course, the "true" result is =
16.9.=20
But we cannot express 16.9 in an integer. So we round. The traditional =
approach=20
for computer integer arithmetic is to always round down. =
<BR><BR>Mathemeticians=20
would tell us that we should round anything from 0.0 up to 0.49999999... =
as 0,=20
and anything from 0.500000000...01 up to 0.9999999999999999... as 1. =
There is a=20
gray area for 0.5 exactly. I was taught a convention that in that case, =
you=20
round to the even-numbered integer. <BR><BR>From that prespective, =
RetroDan's=20
solution comes much closer to the "mathematically" correct solution. =
169/10 =3D=20
17. <BR><BR>As for the amount of pushing and popping required... well, =
that's=20
relative to the register usage conventions at hand. In the worst case =
(with all=20
destoryed registers saved and restored), RetroDan's solution is still =
smaller=20
and faster than the best-case (with no destroyed registers saved and =
restored)=20
"Lenze" solution.
<HR>
 <B>clawson</B> - Mar 31, 2006 - 09:47 PM<BR><B>Post subject: </B>RE: =
[DIS][ASM]=20
Dirty Math Tricks
<HR class=3Dsep>
 Yup, actually I thought the *26 then ditch 8 bit thing was really =
clever.=20
Obviously it works because 26/256 is 0.1015625 which for small numbers =
is OK as=20
a way of multiplying by roughly 0.1. If you tried a larger value like =
800 then I=20
guess it'd be 800 * 26 =3D 20,800 and divided by 256 this is then 81 - =
so the=20
extra 0.0015625 has come into play to create the error. But on small =
numbers it=20
is a clever technique for an "integer divide" <BR><BR>In fact just =
checked and=20
it's good for all values up to 630 in fact, the first one where it goes =
wrong is=20
631 <BR><BR>Cliff
<HR>
 <B>alenze</B> - Mar 31, 2006 - 11:53 PM<BR><B>Post subject: </B>RE: =
[DIS][ASM]=20
Dirty Math Tricks
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR>From that prespective, RetroDan's solution =
comes=20
much closer to the "mathematically" correct solution. 169/10 =3D 17.=20
<BR></DIV><BR><BR>Ah well, Luke - for '169', yes. But even if we assume =
an=20
'implicit rounding' scheme, this is not handled correctly, for ex. in =
the range=20
0-9 we get '0' as result up to dividend 9, ditto e.g. in the 50-59 range =
('5' up=20
to 59). <BR><BR>Mathematically correct - as to the mathematicans - would =
be the=20
'increment result' from '5' or '55' upwards. OP claims '100% correct' =
for the=20
algorithm which it isn't. <BR>It would be correct if it either were =
returning=20
the remainder together with the result or providing the mathematically =
correct=20
rounding you described. <BR><BR>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>In the worst case (with all destroyed =
registers saved=20
and restored), RetroDan's solution is still smaller and faster than the=20
best-case (with no destroyed registers saved and restored) "Lenze" =
solution.=20
</DIV><BR><BR>True, except for the fact that the OP is manipulatively =
comparing=20
a 'sort of 8 bit integers division' (nice as long as you don't need =
correct=20
results) with a <SPAN style=3D"FONT-WEIGHT: bold">16</SPAN> bit integers =
division=20
(add another 6 cycles to get the remainder - blows it up to 31 ... =
geeeze ...)=20
which, thanks to Mr Jones, <SPAN style=3D"FONT-WEIGHT: bold">does</SPAN> =
return=20
correct results. <BR><BR>BTW: As this is the 'tutorial' forum (contents =
aimed at=20
beginners) I honestly think that it would be more helpful if an =
approximation=20
technique were explecitely labeled as such instead of trying to sell it =
off as=20
real binary mathematics.
<HR>
 <B>RetroDan</B> - Apr 01, 2006 - 12:05 AM<BR><B>Post subject: </B>Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle>alenze wrote:</DIV>
<DIV class=3Dquotecontent>BTW: As this is the 'tutorial' forum (contents =
aimed at=20
beginners) I honestly think that it would be more helpful if an =
approximation=20
technique were explecitely labeled as such instead of trying to sell it =
off as=20
real binary mathematics. </DIV><BR><BR>I apologoize Alenze, as the =
comparison=20
was not meant to in any way diminsh the excellent routines you have in =
your=20
Div_xx Package. It is full of "tried and true" routine, and are backed =
by the=20
work of Jones. If anyone is looking for "correct" routine I recommend =
them=20
highly <BR><BR>However, I don't think you read the CAVEAT LECTOR warning =
in my=20
first post. These postings are to discuss "Dirty Math Tricks" and =
hopefully have=20
some fun at the same time. If anyone is uneasy about what I'm doing, I =
suggest=20
they stick to the proven routines like the ones you and Atmel provide =
and forget=20
my threads even exist.
<HR>
 <B>lfmorrison</B> - Apr 01, 2006 - 12:46 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 "<SPAN style=3D"TEXT-DECORATION: underline">Closer</SPAN> to =
mathematically=20
correct". I wasn't claiming that it was a miracle cure-all solution. In =
fact, it=20
conveniently works out that way by pure coincidence of the range of =
numbers=20
involved.. <BR><BR>Anyway... <SPAN style=3D"FONT-STYLE: italic">The =
"traditional"=20
approach to integer division (ignoring remainders for the moment), and =
Retro's=20
"radical approach" to integer division are <SPAN style=3D"FONT-WEIGHT: =
bold">both=20
wrong</SPAN> when compared to result using real numbers.</SPAN> =
<BR><BR>When=20
compared to the "real number" result, the traditional results will =
always be=20
less than or equal to the true result, with a maximum absolute error =
error of -1=20
LSB, and this maximum error is repeated consistently with a periodicity =
of 10=20
for all possible inputs. <BR><BR>RetroDan's results may differ from the =
"real=20
number" result as well. The result may be greater than or less than the =
"real=20
number" result. But it, too, will have a maximum absolute error of +/-1 =
LSB for=20
the range of inputs we're interested in. <BR><BR>Note that the original =
intent=20
of this thread was only to do 8-bit division by 10. And we actually only =

approach an absolute error of -1 LSB at the lower extreme with inputs of =
around=20
0, and +1 LSB at the upper extreme with inputs of around 630. In the =
middle of=20
the range, the aboslute error will be limited to a band of +/- 0.5 LSB=20
<BR><BR>In light of these results, I don't think it's fair to label his =
as "more=20
wrong" than the traditional results. <BR><BR>Of course, if you want to =
have=20
access to the remainders so that your application can fine-tune its=20
interpretation of the result, then that's a strong argument in favour of =
some=20
other approach.
<HR>
 <B>lfmorrison</B> - Apr 01, 2006 - 01:08 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Finding remainders: <BR>- Multiply the result by 10. Label as 'x'. =
<BR>-=20
Subtract 'x' from the original input. <BR>- This result is equal the the =

"Remainder". Using RetroDan's code, the remainder can either "positive" =
or=20
"negative", but it will always have a magnitude of 10 or less. If =
negative, then=20
feel free to subtract 1 from the quotient and add 10 to the remainder. =
And=20
presto! You have a result that is totally identical to the "Lenze" =
result, for=20
all possible 8-bit inputs. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>; RetroDan's original code <BR>DIV10: LDI B,51 =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp;MUL A,B <BR>&nbsp; &nbsp; &nbsp; &nbsp;INC R1&nbsp;=20
&nbsp;;R1=3DA/5 <BR>&nbsp; &nbsp; &nbsp; &nbsp;LSR R1&nbsp; =
&nbsp;;R1=3D(A/5)/2 =3D=20
A/10 <BR>; Luke's insertion <BR>&nbsp; &nbsp; &nbsp; &nbsp;MOV C, R1 =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp;LDI B, 10 <BR>&nbsp; &nbsp; &nbsp; &nbsp;MUL C, B =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp;SUB A, R0 <BR>&nbsp; &nbsp; &nbsp; &nbsp;; 'A' =
contains the=20
(signed) remainder. <BR>&nbsp; &nbsp; &nbsp; &nbsp;; sign of the =
remainder=20
indicates whether it is an: <BR>&nbsp; &nbsp; &nbsp; &nbsp;; - =
under-estimate=20
(positive remainder), or <BR>&nbsp; &nbsp; &nbsp; &nbsp;; - =
over-esitmate=20
(negative remainder) <BR>&nbsp; &nbsp; &nbsp; &nbsp;; 'C' contains the =
quotient=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;; Now a 100% _mathematically_ correct =
result for=20
all 8-bit inputs. <BR>&nbsp; &nbsp; &nbsp; &nbsp;; (Destroys the =
original input=20
operand 'A'. <BR>&nbsp; &nbsp; &nbsp; &nbsp;;&nbsp; one could return the =

remainder in register <BR>&nbsp; &nbsp; &nbsp; &nbsp;;&nbsp; 'B' at the =
cost of=20
one extra MOV instruction.) <BR>&nbsp; &nbsp; &nbsp; &nbsp;RET </DIV>
<HR>
<B>Koshchi</B> - Apr 01, 2006 - 03:17 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Regarding the division by 5 routine you said: <BR>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>Hmm, we're alway off by minus one, so if we =
add one, we=20
should be right on the money! </DIV><BR>But the only numbers that you =
checked=20
were ones that were actually divisible by five. In fact, these are the =
<SPAN=20
style=3D"FONT-WEIGHT: bold">only</SPAN> numbers where this routine =
returns the=20
correct answer. If someone wants to use this, then some correction would =

definitely be necessary. What I would suggest is to not add the one, =
then find=20
the remainder as lfmorrison points out. In this case the remainder will =
always=20
be in the range of [0, 5]. If the remainder is 5, add one to the =
quotient and=20
make the remainder 0. Otherwise, the quotient and the remainder are =
correct.=20
<BR><BR>Applying this to the divide by 10 (the '* 51' version, not the =
'* 26'=20
version), again if you drop the 'add one', the remainder is always in =
the range=20
of [0, 10]. So again the only adjustment is for a remainder of 10. =
<BR><BR>Keep=20
in mind that these remainder ranges are only valid if the original =
number is 8=20
bit. I quickly goes awry for larger numbers. Even 261 produces an out of =
range=20
remainder. You could subtract 10 (or 5 for the div by 5) from the =
remainder=20
instead of just making it 0 to extend the range. To be more specific, it =
will be=20
correct as long as the <SPAN style=3D"FONT-WEIGHT: bold">answer</SPAN> =
fit in 8=20
bits.
<HR>
 <B>alenze</B> - Apr 01, 2006 - 05:22 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 One way to do this (sorry, lfmorrison's signed remainder isn't always=20
mathematically correct - "we should round anything from 0.0 up to =
0.49999999...=20
as 0, and anything from 0.500000000...01 up to 0.9999999999999999... as =
1":=20
<BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>; Division by 10, useing reciprocal =
multiplication=20
<BR>; <BR>; Call with: <BR>;&nbsp; &nbsp;8 bit dividend in r16 <BR>; =
<BR>;=20
Returns: <BR>;&nbsp; &nbsp;Result in r16 <BR>;&nbsp; &nbsp;Remainder in =
r18=20
<BR><BR>&nbsp; &nbsp;mov&nbsp; &nbsp;r18, r16&nbsp; &nbsp;; save =
original=20
dividend <BR>&nbsp; &nbsp;ldi&nbsp; &nbsp;r17,26&nbsp; &nbsp;&nbsp; =
&nbsp;;=20
reciprocal, scaled *256, off a bit <BR>&nbsp; &nbsp;mul&nbsp; =
&nbsp;r16,r17=20
<BR><BR>; result of multiplication now in r1:r0 <BR>; use only r1, =
thereby=20
effectively divide by 256 <BR>&nbsp; &nbsp;dec&nbsp; &nbsp;r1&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; if imprecise scaling value influences result, <BR>&nbsp; =
&nbsp;&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; result will be '+1'. Decrement to =
avoid neg.=20
<BR>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; value in later =

subtraction <BR>&nbsp; &nbsp;ldi&nbsp; &nbsp;r17,10&nbsp; &nbsp;&nbsp; =
&nbsp;;=20
re-use r17 for divisor <BR>&nbsp; &nbsp;mov&nbsp; &nbsp;r16,r1&nbsp;=20
&nbsp;&nbsp; &nbsp;; save result/256 <BR>&nbsp; &nbsp;mul&nbsp;=20
&nbsp;r16,r17&nbsp; &nbsp;&nbsp; &nbsp;; find remainder by =
multiplication of=20
result by 10d <BR><BR>; result again in r1:r0 <BR>; get remainder and =
correct=20
result of 'by 10' <BR>&nbsp; &nbsp;sub&nbsp; &nbsp;r18,r0 <BR>&nbsp;=20
&nbsp;cpi&nbsp; &nbsp;r18,10 <BR>&nbsp; &nbsp; &nbsp; &nbsp; brlo&nbsp;=20
&nbsp;done <BR>&nbsp; &nbsp;subi&nbsp; &nbsp;r18,10 <BR>&nbsp; =
&nbsp;inc&nbsp;=20
&nbsp;r16 <BR><BR>done: <BR>; result in r16, remainder in r18 =
<BR><BR>;optional=20
rounding: <BR>&nbsp; &nbsp;cpi&nbsp; &nbsp;r18,5 <BR>&nbsp; =
&nbsp;brlo&nbsp;=20
&nbsp;done_r <BR>&nbsp; &nbsp;inc&nbsp; &nbsp;r16 <BR>done_r:=20
<BR><BR></DIV><BR><BR>(Quick hack, up to two or three cycles could be =
shaved=20
off)
<HR>
 <B>Broxbourne</B> - Apr 01, 2006 - 09:04 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 I'm going to start with an apology here, because I might be thinking=20
differently, and appear to be stiffling a very simulating and valuable=20
discussion. However as a tutorial, I feel this thread is misplaced. It =
should be=20
in the main forum. <BR><BR>My thoughts of a tutorial are as an =
introduction, a=20
quickstart guide, a pointer to get going and excited. It is a place for =
Newbies=20
to look and gain confidence, and make things. Get involved and learn. =
Good=20
examples to simply use (and with luck considered later), just standard =
routines.=20
<BR><BR>If my manager came up and said, "Eric, we stock a 4k device, the =
next=20
part up is $5 and that will take us under", then I would be =
fantastically=20
interested in this thread. But If I had just found this site, looking =
for=20
information, I might be scared away by the academic discourse of the =
moment. I'm=20
looking for gentle introductions to do this, do that. If the device =
cannot=20
divide by 10, and I cannot comprehend the details that experienced =
people are=20
debating, then I'm off. Another Newbie scared away. <BR><BR>Engineering =
is about=20
compromises."Gerald!, if you can do it in a day just get on with it.". =
Versus,=20
"A new part in our inventory, can't you make it smaller". Such pragmatic =
stuff=20
is key to success, but we have to be careful about introducing it here =
(apart=20
from sowing thoughts). <BR><BR>I hope my opinion is understood in a =
positive=20
sense. It is only one view among so many good people. <BR>Cheers All.
<HR>
 <B>lfmorrison</B> - Apr 01, 2006 - 09:45 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Frankly, I don't buy that "negative remainder isn't correct" argument.=20
<BR><BR>It's a non-standard representation. So are improper fractions. =
But just=20
like improper fractions, the result is numerically dead-on. =
<BR><BR>AFAIC, 25=20
divided by 4 can be perfectly legally expressed as 6 remainder 1. And =
that is=20
exactly identical to 5 remainder 5, or 7 remainder -3. <BR><BR>The only =
possible=20
result from RetroDan's expression would still be guaranteed to be within =
1 LSB=20
of the true result. <SPAN style=3D"FONT-WEIGHT: bold">And the =
"traditional=20
approach" cannot offer any better than getting within 1 LSB =
either.</SPAN>=20
<BR><BR>But if it really bothers you, then you could always test the =
sign bit of=20
the remainder... if it is set, then subtract 1 from the quotient and add =
10 to=20
the remainder. <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>DIV10: LDI B,51 <BR>&nbsp; &nbsp;MUL A,B =
<BR>&nbsp;=20
&nbsp;INC R1&nbsp; &nbsp;;R1=3DA/5 <BR>&nbsp; &nbsp;LSR R1&nbsp; =
&nbsp;;R1=3D(A/5)/2=20
=3D A/10 <BR>; Luke's insertion <BR>&nbsp; &nbsp;MOV C, R1 <BR>&nbsp; =
&nbsp;LDI B,=20
10 <BR>&nbsp; &nbsp;MUL C, B <BR>&nbsp; &nbsp;SUB A, R0 <BR>&nbsp; =
&nbsp;; 'A'=20
contains the (signed) remainder. <BR>&nbsp; &nbsp;; sign of the =
remainder=20
indicates whether it is an: <BR>&nbsp; &nbsp;; - under-estimate =
(positive=20
remainder), or <BR>&nbsp; &nbsp;; - over-esitmate (negative remainder)=20
<BR>&nbsp; &nbsp;; 'C' contains the quotient <BR>&nbsp; &nbsp;; We can =
return=20
here with a totally valid and numerically correct result. <BR>&nbsp; =
&nbsp;; But=20
for the sticklers among us, let's convert it <BR>&nbsp; &nbsp;; to a =
"cannonical=20
form". <BR>&nbsp; &nbsp;SBRS A, 7 ; test the sign of result. <BR>&nbsp;=20
&nbsp;RJMP PositiveRemainder <BR>; We have a negative remainder; =
subtract 1 from=20
<BR>; the quotient and add 10 to the remainder. <BR>&nbsp; &nbsp;DEC C=20
<BR>&nbsp; &nbsp;ADD A, B <BR>PositiveRemainder <BR>; The result is now =
in=20
perfect "cannonical" form. <BR>&nbsp; &nbsp;RET </DIV><BR><BR>And given =
the=20
limited range of values we're concerned with here, that result (after a =
single=20
check of the sign on the remainder, and possibly a single subtraction of =
1 /=20
addition of 10) will be in the "cannonical" form. (Ie. a guaranteed=20
underesitmate in the result, and a remainder that is guaranteed to be =
positive,=20
and bound between 0 and 9.)
<HR>
 <B>RickB</B> - Apr 01, 2006 - 10:19 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Broxbourne: I agree 100%. The give and take on this subject should be =
hashed=20
out in another forum. Then and ONLY then should it become a tutorial. =
After all,=20
what is a beginner to think when seeing the differing opinions. Most =
beginners=20
are in no position to judge who is right or wrong on the details. I =
would like=20
to see it here once that is done. <BR><BR>Rick
<HR>
 <B>RetroDan</B> - Apr 01, 2006 - 10:35 AM<BR><B>Post subject: </B>Re: =
RE: Re:=20
RE: [DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle>Broxbourne wrote:</DIV>
<DIV class=3Dquotecontent>I'm going to start with an apology here, =
because I might=20
be thinking differently, and appear to be stiffling a very simulating =
and=20
valuable discussion. However as a tutorial, I feel this thread is =
misplaced. It=20
should be in the main forum. <BR>&lt;snip&gt; <BR>I hope my opinion is=20
understood in a positive sense. It is only one view among so many good =
people.=20
<BR>Cheers All. </DIV><BR><BR>Thanks for the feed-back. <BR><BR>You may =
not know=20
this, but actual tutorials are labeled [TUT] by moderator to distiguish =
them=20
from other threads. The moderator has labeled this thread [DIS] for =
discussion.=20
Another label is [CODE] for code segments that are not tutorials. I =
think this=20
information can be found in the "Sticky-the-Bear" threads at the top of =
the=20
list.
<HR>
 <B>Broxbourne</B> - Apr 01, 2006 - 11:10 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Re: RE: [DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Dan, Thank you for the information. I did not realize the moderator was =

adjusting the titles of the thread according to the intended audience. I =
just=20
thought this was the place to find tutorials and good examples of code =
and AVR=20
applications. <BR>Thanks for clarifying that. I'll make sure I only read =
[TUT]=20
postings from now on to avoid getting confused by the more heady =
academic stuff,=20
although I am still surprised to see such specialised discussion in a =
beginner=20
forum. <BR>Practically Yours.
<HR>
 <B>alenze</B> - Apr 01, 2006 - 06:17 PM<BR><B>Post subject: </B>RE: Re: =
RE: Re:=20
RE: [DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Hi Luke, <BR><BR>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>sorry, lfmorrison's signed remainder isn't =
always=20
mathematically correct - "we should round anything from 0.0 up to =
0.49999999...=20
as 0, and anything from 0.500000000...01 up to 0.9999999999999999... as =
1"=20
</DIV><BR><BR>definitely didn't come through quite as intended (sorry =
about=20
that): <BR><BR>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>Frankly, I don't buy that "negative remainder =
isn't=20
correct" argument </DIV><BR><BR>You are right and I phrased it badly: of =
course=20
the <SPAN style=3D"FONT-WEIGHT: bold">signed remainder</SPAN> is =
correctly=20
calculated (cleaner than in my example, too - 3 or four cycles saved).=20
<BR><BR>It's the <SPAN style=3D"FONT-WEIGHT: bold">'inbuild =
rounding'</SPAN> whose=20
threshold is off by one, mathematically speaking ( <IMG border=3D0 =
alt=3DSmile=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_smile=
.gif"> ):=20
<BR><BR>The quotient 'n.5' (6.5 for example if dviding 65/10) should =
already be=20
rounded up to n+1 ('7'), here it is still left at '6'. <BR>66/10 (6.6) =
is=20
correctly rounded to '7' as 64/10 (6.4) becomes a rounded '6'. It's just =
the=20
'.5' rounding which doesn't quite work (aren't those mathematicians a=20
fascinating breed?). <BR><BR>Sorry again - apologies to Broxbourne, too, =
guess=20
we got carried away a little here ...
<HR>
 <B>RetroDan</B> - Apr 06, 2006 - 10:37 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Re: RE: [DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Thank you all for the wonderful feed-back. The information was =
invaluable and=20
probably saved me a lot of head-scratching as you'll soon find out. =
<BR><BR>I=20
was pleased-as-punch that my "quirky" little division by 10 routine =
worked. I=20
was even more delighted to find out that it did a pretty good job of =
rounding to=20
boot. However, when I got around to using it for my original purpose, I =
realized=20
that rounding was the last thing I wanted. <BR><BR>The original use for =
the=20
routine was to break-down an unsigned single byte for display on the =
Butterfly=20
LCD. Well I was getting results like: 74, 75, 76, 77, 80, 80, 80, 81, =
82, 83.=20
Obviously the little DIV10 routine was working over-time and rounding, =
so a few=20
fine adjustments were needed to "UN-ROUND" the results. <BR><BR>I know =
that you=20
guys have already worked out your own versions, here is mine: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>;-----------------------------------; <BR>; =
RETRO=20
(SYNTHETIC) DIVISION BY 10&nbsp; ; <BR>; ANSWER IN R1, R0=3DREM, =
A:PRESERVED ;=20
<BR>;-----------------------------------; <BR>DIV10:&nbsp; PUSH B =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; LDI&nbsp; B,26&nbsp; &nbsp;;MUL BY 26 <BR>&nbsp; =
&nbsp;=20
&nbsp; &nbsp; MUL&nbsp; A,B&nbsp; &nbsp; ;R1=3DA/10 <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp; PUSH R1&nbsp; &nbsp; &nbsp;;BRUTE-FORCE CALC OF REMAINDER&nbsp; =
&nbsp;=20
&nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; LDI&nbsp; B,10&nbsp; &nbsp;;CALC =
REM=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; MUL&nbsp; R1,B&nbsp; =
&nbsp;;R0=3D10xR1(QUOT)=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; POP&nbsp; R1&nbsp; &nbsp; &nbsp;;RESTORE =
QUOT=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; SUB&nbsp; R0,A&nbsp; &nbsp;;SUBTRACT =
REMx10=20
<BR>NODJST: NEG&nbsp; R0&nbsp; &nbsp; &nbsp;;MAKE POSITIVE <BR>&nbsp; =
&nbsp;=20
&nbsp; &nbsp; &nbsp;BRPL NONEG ;STILL NEG? <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;=20
ADD&nbsp; R0,B&nbsp; &nbsp;;OOPS MAKE <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
DEC&nbsp;=20
R1&nbsp; &nbsp; &nbsp;;ADJUSTMENTS <BR>NONEG:&nbsp; &nbsp;RET=20
<BR></DIV><BR><BR>If you're wondering why I calculate the remainder =
"backwards"=20
then negate it, it's to preserve the value of A. If there's no need to =
preserve=20
A then the remainder could be calculated the other-way-around and =
eliminate the=20
need for the NEG R0 line. However, you should be forewarned that =
"letting go" a=20
NEG R0 without very good cause could lead to a charge of racism! Other =
than=20
removing that one statement I don't know if it can be optimized any =
further, but=20
it sure would be nice.
<HR>
 <B>brum103</B> - Oct 08, 2006 - 06:28 AM<BR><B>Post subject: =
</B>division by=20
ten with a bite
<HR class=3Dsep>
 this topic got me thinking a while ago. <BR><BR>I really liked the =
super simple=20
idea of a divide by ten routine, but didn't like the error it has. So i =
was=20
thinking a little further about the routine with the multiplier. =
<BR><BR>I was=20
thinking the error came because of the difference between 26 and 25.6, =
and=20
started thinking about a way to make this error smaller, so i came up =
with the=20
idea of 65536/10 which would make 6553.6 or 6554 which has less error.=20
<BR><BR><BR>I wrote a test program on the ti83 to verify my idea, and =
found that=20
it is correct up to 14 bits. <BR>listing: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>:ClrHome <BR>:0-&gt;G <BR>:0-&gt;F =
<BR>:6554-&gt;B=20
<BR>:For(A,1,20000) <BR>:If (iPart(A/10)=3DiPart((A*B)/65536)) <BR>:Then =

<BR>:G+1-&gt;G <BR>:Else <BR>:F+1-&gt;F <BR>:If F&lt;4 =
<BR>:Output(F+2,1,A=20
<BR>:End <BR>:Output(1,1,G <BR>:Output(2,1,F <BR>:End =
<BR></DIV><BR><BR>This=20
told me the first error would occur at 16389. <BR><BR>So up to 14 bit =
accurate!=20
<BR>Enough for a 8 bit number <BR><BR>I wrote me some asm and came up =
with:=20
<BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>div10: <BR>; put your value in temp =
<BR>;&nbsp;=20
&nbsp;ldi temp, 11&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp; ; example value is in temp <BR>ldi mul_constL, low(6554) <BR>ldi=20
mul_constH, high(6554)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; load =
multiply=20
value <BR>mul temp, mul_constL&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; mul lower <BR>movw result_M2:result_L2, R1:R0&nbsp; &nbsp;&nbsp; =
&nbsp;;=20
store <BR>mul temp, mul_constH&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; mul higher <BR>clr&nbsp; &nbsp;result_H2&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <BR>add result_M2, =
R0&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; add value =
<BR>adc=20
result_H2, R1 <BR>ret <BR>; result is now in result_H2 =
<BR></DIV><BR><BR>The=20
code above is hogging up to much vars. So i optimized it a little and =
came up=20
with: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>div10: <BR>; input value in temp <BR>ldi =
tempL,=20
low(6554) <BR>ldi tempH, high(6554)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; load multiply value <BR>mul temp, tempL&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; mul lower <BR>mov tempL, =
R1&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; =
store=20
<BR>mul temp, tempH&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;&nbsp; &nbsp;; mul higher <BR>clr tempH&nbsp; &nbsp;&nbsp; =
&nbsp;&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <BR>add tempL, R0&nbsp;=20
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; =
add=20
value <BR>adc tempH, R1 <BR>ret <BR>; result is now in tempH=20
<BR></DIV><BR><BR>this is better. <IMG border=3D0 alt=3D"Very Happy"=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_biggr=
in.gif">
<HR>
 <B>JohnD</B> - Oct 21, 2006 - 09:56 PM<BR><B>Post subject: </B>Register =
already=20
defined by the .def directive
<HR class=3Dsep>
 I tried running your 8 bit division code:=20
<BR>[quote];*************************************************************=
**************=20
<BR>;* "div8u" - 8/8 Bit Unsigned Division <BR>;* <BR>;* This subroutine =
divides=20
the two register variables "dd8u" (dividend) and <BR>;* "dv8u" =
(divisor). The=20
result is placed in "dres8u" and the remainder in <BR>;* "drem8u". =
<BR>;* <BR>;*=20
Number of words :14 <BR>;* Number of cycles :97 <BR>;* Low registers =
used :1=20
(drem8u) <BR>;* High registers used :3 (dres8u/dd8u,dv8u,dcnt8u)=20
<BR>;********************************************************************=
*******=20
<BR><BR>.def drem8u =3Dr15 ;remainder <BR>.def dres8u =3Dr16 ;result =
<BR>.def dd8u=20
=3Dr16 ;dividend <BR>.def dv8u =3Dr17 ;divisor <BR>.def dcnt8u =3Dr18 =
;loop counter=20
<BR><BR>div8u: sub drem8u,drem8u ;clear remainder and carry <BR>ldi =
dcnt8u,9=20
;init loop counter <BR>d8u_1: rol dd8u ;shift left dividend <BR>dec =
dcnt8u=20
;decrement counter <BR>brne d8u_2 ;if done <BR>ret ; return <BR>d8u_2: =
rol=20
drem8u ;shift dividend into remainder <BR>sub drem8u,dv8u ;remainder =3D =
remainder=20
- divisor <BR>brcc d8u_3 ;if result negative <BR>add drem8u,dv8u ; =
restore=20
remainder <BR>clc ; clear carry to be shifted into result <BR>rjmp d8u_1 =
;else=20
<BR>d8u_3: sec ; set carry to be shifted into result <BR>rjmp d8u_1 =
<BR><BR>When=20
I build this code, it gives me an error: "Register already defined by =
the .def=20
directive". The above code refers to R16 with two different labels which =
should=20
be okay. Is there a reason why it gives me this error? <BR><BR>Thanks, =
<BR>John
<HR>
 <B>Koshchi</B> - Oct 21, 2006 - 10:43 PM<BR><B>Post subject: </B>RE: =
Register=20
already defined by the .def directive
<HR class=3Dsep>
 I've gotten this error recently as well. I think that it used to work, =
but it=20
has changed in recent versions of AVR Studio. Not sure if this is a bug =
or a=20
deliberate change.
<HR>
 <B>froody</B> - Oct 22, 2006 - 04:37 AM<BR><B>Post subject: </B>RE: =
Register=20
already defined by the .def directive
<HR class=3Dsep>
 First, let me say that I have no clue about AVR coding. An Arduino =
board is in=20
the mail, but I haven't gotten it yet. I love digital math, though. So =
here's a=20
little different take on the OP's trick. <BR><BR>Dividing is the same =
thing as=20
multiplying by the inverse, so dividing by 10 is the same as multiplying =
by 0.1.=20
The problem is that there isn't a neat binary representation of 0.1. But =
it=20
turns out that you can use a good enough 16-bit representation of 0.1 to =
get=20
accurate results (meaning the same number as division by 10, rounded =
down as=20
expected). With some simple fixed-point math you can then do your =
multiply,=20
discard the mantissa (the bit after the . (or , for Europeans)) and =
there you=20
go. <BR><BR>What fixed-point format to use? It'll be obvious in a =
minute. Let's=20
just assume 8 bits of mantissa for now and start finding the binary=20
representation of 0.1d (decimal). Really what you're looking for is =
which powers=20
of -2 you need to add up to get as close to 0.1 as possible. If you do =
that, you=20
find: <BR>1/10 =3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + 0/128 + 1/256 =
<BR>the=20
binary representation for this is: <BR>00000000.00011001 <BR><BR>So =
that's the=20
16-bit number you should multiply the original number by to divide by =
10. But=20
you'll notice we can use extra mantissa bits, as long as the top byte is =
0. (If=20
the top byte isn't 0 we might get overflow when we multiply.) So let's =
use 11=20
mantissa bits: <BR>1/10 =3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + =
0/128 + 1/256=20
+ 1/512 + 0/1024 + 1/2048 <BR>or 00000.00011001101 <BR><BR>Here it is =
all nicely=20
coded up in C. I've tested it for 0-255 and it gives the same result as =
C's /10=20
operation for every one. gcc did some awful things to the assembly, but =
I'll=20
leave that part up to you guys because you're much better at it than I =
am. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>uint8_t div10_fp(uint8_t number) <BR>{ =
<BR>&nbsp; &nbsp;=20
// 1/10th with 11 mantissa bits <BR>&nbsp; &nbsp; // 1/10th =3D 0/2 + =
0/4 + 0/8 +=20
1/16 + 1/32 + 0/64 + 0/128 + 1/256 + 1/512 + <BR>&nbsp; &nbsp; // 0/1024 =
+=20
1/2048 <BR>&nbsp; &nbsp; // 0.00011001101 <BR>&nbsp; &nbsp; uint16_t =
tenth =3D=20
0xcd; <BR>&nbsp; &nbsp; // result with 11 mantissa bits <BR>&nbsp; =
&nbsp;=20
uint16_t result =3D number * tenth; <BR>&nbsp; 9a:&nbsp; &nbsp;99 =
27&nbsp; &nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;eor&nbsp; &nbsp; &nbsp;r25, r25 <BR>&nbsp; =
9c:&nbsp;=20
&nbsp;2d ec&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ldi&nbsp; &nbsp; =
&nbsp;r18,=20
0xCD&nbsp; &nbsp; &nbsp; &nbsp;; 205 <BR>&nbsp; 9e:&nbsp; &nbsp;30 =
e0&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ldi&nbsp; &nbsp; &nbsp;r19, 0x00&nbsp; =
&nbsp;=20
&nbsp; &nbsp;; 0 <BR>&nbsp; a0:&nbsp; &nbsp;82 9f&nbsp; &nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp;mul&nbsp; &nbsp; &nbsp;r24, r18 <BR>&nbsp; a2:&nbsp; =
&nbsp;a0=20
01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movw&nbsp; &nbsp; r20, r0 =
<BR>&nbsp;=20
a4:&nbsp; &nbsp;83 9f&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul&nbsp; =
&nbsp;=20
&nbsp;r24, r19 <BR>&nbsp; a6:&nbsp; &nbsp;50 0d&nbsp; &nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp;add&nbsp; &nbsp; &nbsp;r21, r0 <BR>&nbsp; a8:&nbsp; =
&nbsp;92=20
9f&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mul&nbsp; &nbsp; &nbsp;r25, =
r18=20
<BR>&nbsp; aa:&nbsp; &nbsp;50 0d&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=20
&nbsp;add&nbsp; &nbsp; &nbsp;r21, r0 <BR>&nbsp; ac:&nbsp; &nbsp;11 =
24&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eor&nbsp; &nbsp; &nbsp;r1, r1 =
<BR>&nbsp;=20
ae:&nbsp; &nbsp;ca 01&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;movw&nbsp; =
&nbsp;=20
r24, r20 <BR>&nbsp; &nbsp; // Drop mantissa to round down. <BR>&nbsp; =
&nbsp;=20
return result &gt;&gt; 11; <BR>&nbsp; b0:&nbsp; &nbsp;89 2f&nbsp; &nbsp; =
&nbsp;=20
&nbsp; &nbsp; &nbsp;mov&nbsp; &nbsp; &nbsp;r24, r25 <BR>&nbsp; b2:&nbsp; =

&nbsp;99 27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eor&nbsp; &nbsp; =
&nbsp;r25,=20
r25 <BR>&nbsp; b4:&nbsp; &nbsp;86 95&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=20
&nbsp;lsr&nbsp; &nbsp; &nbsp;r24 <BR>&nbsp; b6:&nbsp; &nbsp;86 95&nbsp; =
&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;lsr&nbsp; &nbsp; &nbsp;r24 <BR>&nbsp; =
b8:&nbsp;=20
&nbsp;86 95&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lsr&nbsp; &nbsp; =
&nbsp;r24=20
<BR>} <BR>&nbsp; ba:&nbsp; &nbsp;99 27&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =

&nbsp;eor&nbsp; &nbsp; &nbsp;r25, r25 <BR>&nbsp; bc:&nbsp; &nbsp;08 =
95&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret <BR></DIV><BR><BR>You can do the =
same=20
thing for dividing by any constant, and I'm actually kind of surprised =
gcc=20
doesn't just do this for me. <BR><BR>Tim
<HR>
 <B>brum103</B> - Oct 22, 2006 - 09:05 PM<BR><B>Post subject: </B>RE: =
Register=20
already defined by the .def directive
<HR class=3Dsep>
 That is a great idea froody! <BR><BR>I had a look at your code, and =
optimized=20
it a bit. <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>; the input number must be in register =
"input" <BR>;=20
value/10 is in register "result" <BR>; register temp1 and R1:R0 are =
clobbered=20
<BR>div10: <BR>&nbsp; &nbsp;ldi temp1, 205 <BR>&nbsp; &nbsp;mul temp1, =
input=20
<BR>&nbsp; &nbsp;lsr R1 <BR>&nbsp; &nbsp;lsr R1 <BR>&nbsp; &nbsp;lsr R1=20
<BR>&nbsp; &nbsp;mov result, R1 <BR>&nbsp; &nbsp;ret =
<BR></DIV><BR><BR>edit...=20
<BR><BR>i have written a little test program in ti basic. <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>:ClrHome <BR>:0-&gt;G <BR>:0-&gt;F =
<BR>:For(N,0,1200)=20
<BR>:If (iPart(N/10)=3DiPart((N*205)/2048)) <BR>:Then <BR>:G+1-&gt;G =
<BR>:Else=20
<BR>:F+1-&gt;F <BR>:If F&lt;5 <BR>:Output(2+F,1,N <BR>:End =
<BR>:Output(1,1,"G=3D"=20
<BR>:Output(1,3,G <BR>:Output(2,1,"F=3D" <BR>:Output(2,3,F <BR>:End=20
<BR></DIV><BR><BR>It shows that it is correct up to 1028 and it fails at =
1029,=20
more than enough for 8 bit
<HR>
 <B>froody</B> - Oct 23, 2006 - 04:43 AM<BR><B>Post subject: </B>RE: =
Register=20
already defined by the .def directive
<HR class=3Dsep>
 brum, wow. gcc really sucks, huh? Nice job on optimizing the code. I'm =
going to=20
install gcc 4.1 soon. Hopefully it won't suck as much. =
<BR><BR>Meanwhile, I=20
clarified my original post a bit, and wrote some more, and now it's =
turned into=20
a little article: <BR><BR><SPAN style=3D"FONT-WEIGHT: bold">How to =
divide an=20
unsigned 8-bit integer by a constant.</SPAN> <BR>(c) 2006 by Tim Newsome =

&lt;nuisance@casualhacker.net&gt; <BR>Thanks to RetroDan and several =
other on=20
avrfreaks.net for the inspiration. <BR><BR>Dividing is slow, so let's =
avoid=20
that. Instead, multiply by the inverse. You can write the inverse as a=20
fixed-point binary number. Just like each digit in a normal binary =
number=20
represents a power of 2, each digit after the decimal point in a binary =
number=20
represents a power of -2. So: <BR>10.11 =3D 1 * 2^1 + 0 * 2^0 + 1 * 2^-1 =
+ 1 *=20
2^-2 =3D 2 + 1/2 + 1/4 =3D 2.75 <BR>Example: 0.5 =3D 1/2 =3D 0.1 =
(binary, 1-bit=20
mantissa) <BR>Example: 0.25 =3D 0/2 + 1/4 =3D 0.01 (binary, 2-bit =
mantissa)=20
<BR><BR>Unfortunately there isn't a precise binary representation of =
most=20
fractions, so you have to use an approximation. The same problem happens =
in=20
decimal numbers, just not as often. For instance, 1/3 can be =
approximated as=20
0.3, which has an error of 0.3-1/3=3D-1/30. A better approximation is =
0.33, which=20
has an error of -1/300. The more digits you add, the smaller the error =
becomes.=20
The same thing is true in binary: <BR>1/3 =3D~ 1/2 =3D 0.1, error =3D =
0.167 <BR>1/3 =3D~=20
0/2 + 1/4 =3D 0.01, error =3D -0.0833 <BR>1/3 =3D~ 0/2 + 1/4 + 1/8 =3D =
0.011, error =3D=20
0.0417 <BR>1/3 =3D~ 0/2 + 1/4 + 0/8 + 1/16 =3D 0.0101, error =3D -0.0208 =

<BR><BR>Because we can't always find the precise inverse, we need to =
find one=20
that's close enough, and gives us the right answer by rounding down =
always.=20
(Rounding down just means ignoring the mantissa bits, which is easy to =
do.) That=20
means we want to find an approximation that is at least as big as the =
real=20
inverse. In other words, the error (computed as approximation minus real =
value)=20
has to be positive. Furthermore, the error multiplied by 255 (our =
largest input=20
value) must be smaller (less negative) than 1/divisor. For dividing by =
3, the=20
error must lie between 0 and 1/(3*255). Let's rework 1/3 keeping the =
error=20
positive, and seeing how many bits we need before the error is small =
enough that=20
we can use the approximation: <BR>1/3 =3D~ 1/2 =3D 0.1, error =3D .167 =
<BR>1/3 =3D~ 1/2=20
+ 0/4 =3D 0.10, error =3D .167 <BR>1/3 =3D~ 0/2 + 1/4 + 1/8 =3D 0.011, =
error =3D .0417=20
<BR>1/3 =3D~ 0/2 + 1/4 + 1/8 + 0/16 =3D 0.0110, error =3D .0417 <BR>1/3 =
=3D~ 0/2 + 1/4 +=20
0/8 + 1/16 + 1/32 =3D 0.01011, error =3D .0104 <BR>1/3 =3D~ 0/2 + 1/4 + =
0/8 + 1/16 +=20
1/32 + 0/64 =3D 0.010110, error =3D .0104 <BR>1/3 =3D~ 0/2 + 1/4 + 0/8 + =
1/16 + 0/32 +=20
1/64 + 1/128 =3D 0.0101011, error =3D .00260 <BR>1/3 =3D~ 0/2 + 1/4 + =
0/8 + 1/16 +=20
0/32 + 1/64 + 1/128 + 0/256 =3D 0.01010110, error =3D .00260 <BR>1/3 =
=3D~ 0/2 + 1/4 +=20
0/8 + 1/16 + 0/32 + 1/64 + 0/128 + 1/256 + 1/512 =3D 0.010101011, error =
=3D .000651=20
<BR><BR>So 9 bits of mantissa is enough, and our inverse is 0.010101011. =
Here is=20
some C code that takes advantage of this: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>uint8_t div3(uint8_t number) <BR>{ <BR>&nbsp; =
&nbsp; //=20
Compute the intermediate value, with 9 mantissa bits. <BR>&nbsp; &nbsp; =
uint16_t=20
intermediate =3D (uint16_t) number * 0xab; <BR>&nbsp; &nbsp; // Return =
the result,=20
chopping off the mantissa bits. <BR>&nbsp; &nbsp; return intermediate =
&gt;&gt;=20
9; <BR>} </DIV><BR><BR>A good compiler should compile that down to a =
single=20
multiply instruction, a shift, and maybe a few extra instructions. This =
is=20
drastically faster than using the generic divide code. <BR><BR>Let's do =
one more=20
example, for division by 10. First figure out the inverse using the =
fewest=20
number of mantissa bits: <BR>1/10 =3D~ 1/2, error =3D 0.400 <BR>1/10 =
=3D~ 0/2 + 1/4,=20
error =3D 0.150 <BR>1/10 =3D~ 0/2 + 0/4 + 1/8, error =3D 0.025 <BR>1/10 =
=3D~ 0/2 + 0/4 +=20
1/8 + 0/16, error =3D 0.025 <BR>1/10 =3D~ 0/2 + 0/4 + 1/8 + 0/16 + 0/32, =
error =3D=20
0.025 <BR>1/10 =3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + 1/64, error =3D =
.00938 <BR>1/10=20
=3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + 1/128, error =3D .00156 =
<BR>1/10 =3D~ 0/2=20
+ 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + 1/128 + 0/256, error =3D .00156 =
<BR>1/10 =3D~ 0/2=20
+ 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + 1/128 + 0/256 + 0/512, error =3D =
.00156=20
<BR>1/10 =3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + 0/64 + 0/128 + 1/256 + =
1/512 +=20
1/1024, error =3D .000586 <BR>1/10 =3D~ 0/2 + 0/4 + 0/8 + 1/16 + 1/32 + =
0/64 + 0/128=20
+ 1/256 + 1/512 + 0/1024 + 1/2048, error =3D .0000977 <BR>Finally we've =
reached=20
the point where 255 * error is less than 1/10. So we need 11 mantissa =
bits, and=20
our inverse is 0.00011001101. Here's the C code: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>uint8_t div10(uint8_t number) <BR>{ <BR>&nbsp; =
&nbsp; //=20
Compute the intermediate value, with 11 mantissa bits. <BR>&nbsp; &nbsp; =

uint16_t intermediate =3D (uint16_t) number * 0xcd; <BR>&nbsp; &nbsp; // =
Return=20
the result, chopping off the mantissa bits. <BR>&nbsp; &nbsp; return=20
intermediate &gt;&gt; 11; <BR>} </DIV><BR><BR>So there you have it. Fast =

division by a constant of an unsigned 8-bit integer. If you followed =
what I've=20
done here, you should be able to extend this to 16-bit or any other =
sized=20
number.
<HR>
 <B>abcminiuser</B> - Oct 23, 2006 - 04:59 AM<BR><B>Post subject: =
</B>RE:=20
Register already defined by the .def directive
<HR class=3Dsep>
 Froody, <BR><BR>Good article. However, in your code examples don't you =
need an=20
explicit cast to the "number" parameter to force GCC to use 16-bit =
operations? I=20
would expect GCC to do the multiplication as 8-bit first, then implicit =
cast to=20
a 16-bit value when storing. <BR><BR>- Dean <IMG border=3D0 =
alt=3D"Twisted Evil"=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_twist=
ed.gif">
<HR>
 <B>froody</B> - Oct 23, 2006 - 05:19 AM<BR><B>Post subject: </B>Re: RE: =

Register already defined by the .def directive
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle>abcminiuser wrote:</DIV>
<DIV class=3Dquotecontent>Good article. However, in your code examples =
don't you=20
need an explicit cast to the "number" parameter to force GCC to use =
16-bit=20
operations? I would expect GCC to do the multiplication as 8-bit first, =
then=20
implicit cast to a 16-bit value when storing. </DIV><BR>Thanks. Good =
point about=20
the typecast. I think it's OK, because the hex constant is implicitly of =
type=20
int, which is 16 bits, on AVR (right?). So it all works out. But it =
certainly is=20
safer to add the typecast, so I'll edit my post and stick it in there.=20
<BR><BR>Tim
<HR>
 <B>Koshchi</B> - Oct 23, 2006 - 07:24 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Register already defined by the .def directive
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>You can do the same thing for dividing by any =
constant,=20
and I'm actually kind of surprised gcc doesn't just do this for me. =
<BR>...=20
<BR>gcc really sucks, huh? </DIV><BR>I don't know how you can come to =
this=20
conclusion from this thread. Up until your post this entire thread has =
been=20
about assembly language and therefore has absolutely nothing to do with =
gcc.=20
Also, the C language has absolutely no knowledge about fixed point =
numbers, so=20
how could you possibly expect it to optimize your code in this manner?
<HR>
 <B>froody</B> - Oct 23, 2006 - 09:21 AM<BR><B>Post subject: </B>Re: RE: =
Re: RE:=20
Register already defined by the .def directi
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle>Koshchi wrote:</DIV>
<DIV class=3Dquotecontent>
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>gcc really sucks, huh? </DIV><BR>I don't know =
how you=20
can come to this conclusion from this thread. Up until your post this =
entire=20
thread has been about assembly language and therefore has absolutely =
nothing to=20
do with gcc. Also, the C language has absolutely no knowledge about =
fixed point=20
numbers, so how could you possibly expect it to optimize your code in =
this=20
manner? </DIV><BR><BR>In the first post you quoted, I showed some C code =
among=20
the assembly code. You can see that gcc's generated code is really =
inefficient.=20
For instance it does a mul by a register known to be 0. (Note that I've =
since=20
installed gcc 4.1.1 and it does a lot better, although there are still =
some=20
obvious optimizations possible.) <BR><BR>Look at this C code: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>uint8_t function(void) { <BR>&nbsp; &nbsp; =
volatile=20
uint8_t val =3D 123; <BR>&nbsp; &nbsp; return val / 10; <BR>} =
</DIV><BR>When I=20
compile it, I get a call to a general divide routine. But the compiler =
knows I'm=20
dividing by a constant, so it could do the exact optimization I =
outlined.=20
Effectively it would rewrite the code to look like: <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>uint8_t function(void) { <BR>&nbsp; &nbsp; =
volatile=20
uint8_t val =3D 123; <BR>&nbsp; &nbsp; return ((uint16_t) val * 0xcd) =
&gt;&gt; 11;=20
<BR>} </DIV><BR>That is actually slightly larger than the original code, =
but a=20
lot faster. If you really care about code size you could just use the =
div10()=20
function. Then function() would be 1 instruction shorter (because you =
don't have=20
to pass 10 to the divide function) but you do take the size penalty of =
div10()=20
(10 instructions in my gcc 4.1.1 build). <BR><BR>Tim
<HR>
 <B>daqq</B> - Jun 14, 2007 - 03:14 PM<BR><B>Post subject: </B>RE: Re: =
RE: Re:=20
RE: Register already defined by the .def dir
<HR class=3Dsep>
 Try removing the "voltatile" keyword. You'll get a far better output.
<HR>
 <B>safari</B> - Jun 14, 2007 - 04:57 PM<BR><B>Post subject: </B>RE: Re: =
RE: Re:=20
RE: Register already defined by the .def dir
<HR class=3Dsep>
 daqq it's an old thread, nearly 3/4 of an year old <BR><IMG border=3D0 =
alt=3DSmile=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_smile=
.gif">=20
<BR><BR>/Safari
<HR>
 <B>futrtrubl</B> - Jun 14, 2007 - 05:11 PM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Re: RE: Register already defined by the .def dir
<HR class=3Dsep>
 Still, I'm glad he brought it back since this will help me. =
<BR><BR>Edward
<HR>
 <B>dksmall</B> - Jun 14, 2007 - 11:47 PM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Re: RE: Register already defined by the .def dir
<HR class=3Dsep>
 Nothing like a nice jolt when I saw who the OP was! <IMG border=3D0 =
alt=3DShocked=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_eek.g=
if"> Then=20
I realized it's an old thread. <IMG border=3D0 alt=3DRazz=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_razz.=
gif">
<HR>
 <B>klini</B> - Dec 19, 2007 - 10:57 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Wouldn't it be nice to not deal with the rounding error? If we were to =
add a=20
compensation amount before multiplying by 26, we then have no error: =
<BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>.def temp1 =3D r16 <BR>.def temp2 =3D r17 =
<BR>.def A =3D r18=20
<BR><BR>// Input: A <BR>// Output: r1 <BR>DivBy10: <BR><BR>&nbsp; =
&nbsp;//=20
calculate the amount needed to add to A to compensate for the rounding =
error to=20
come <BR>&nbsp; &nbsp;// compensation =3D (A + 3) / 64 <BR>&nbsp; =
&nbsp;mov temp2,=20
A <BR>&nbsp; &nbsp;ldi temp1, 3 <BR>&nbsp; &nbsp;add temp2,temp1 =
<BR>&nbsp;=20
&nbsp;// "divide by 64" shortcut <BR>&nbsp; &nbsp;swap temp2 <BR>&nbsp;=20
&nbsp;andi temp2, 15 <BR>&nbsp; &nbsp;lsr temp2 <BR>&nbsp; &nbsp;lsr =
temp2=20
<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp;// now use 'A - compensation' =
<BR>&nbsp;=20
&nbsp;mov temp1, A <BR>&nbsp; &nbsp;sub temp1, temp2 <BR><BR>&nbsp; =
&nbsp;//=20
Multiply by magic number <BR>&nbsp; &nbsp;ldi temp2, 26 <BR>&nbsp; =
&nbsp;mul=20
temp1, temp2 <BR><BR>&nbsp; &nbsp;ret </DIV><BR><BR>I've checked it out =
on my=20
computer and seems like this works good, and doesn't eat many more =
cycles than=20
the original.
<HR>
 <B>Nephazz</B> - Feb 25, 2009 - 02:17 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
Re: RE: Register already defined by the .def dir
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>; the input number must be in register =
"input" <BR>;=20
value/10 is in register "result" <BR>; register temp1 and R1:R0 are =
clobbered=20
<BR>div10: <BR>&nbsp; &nbsp;ldi temp1, 205 <BR>&nbsp; &nbsp;mul temp1, =
input=20
<BR>&nbsp; &nbsp;lsr R1 <BR>&nbsp; &nbsp;lsr R1 <BR>&nbsp; &nbsp;lsr R1=20
<BR>&nbsp; &nbsp;mov result, R1 <BR>&nbsp; &nbsp;ret=20
</DIV><BR></DIV><BR><BR>This one rocks! Saved my day, today <IMG =
border=3D0=20
alt=3DSmile=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_smile=
.gif">
<HR>
 <B>seveprim</B> - Mar 06, 2009 - 09:24 AM<BR><B>Post subject: </B>RE: =
Re: RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 i suppose one could allocate a huge look up table ln FLASH on the =
larger AVR=20
range ... practically instant result which i have done many many years =
ago...=20
(code lost to time)
<HR>
 <B>vbunch</B> - Dec 22, 2009 - 01:34 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Thanks to all for alively discussion. I need help on a 16 bit divide: =
<BR>I=20
have been using the DIV16u straight from apnote 1011 (AVR200) since =
1998, and=20
found a possible error. <BR><BR>When you have $7080 (28,800) divided by =
$3841=20
(14,401), the correct answer is: $0001 and remainder $FFF6 (1.99986).=20
<BR>However, the Atmel DIV16u returns $0001 remainder $383F, quite an =
error.=20
<BR><BR>When you have $7080 (28,800) divided by $3840 (14,400), the =
correct=20
answer is: $0002 and remainder $0000 (2.00000), and the Atmel code =
returns the=20
correct same answer. <BR><BR>Please help, I need a fix fast, or am I =
wrong?=20
<BR><BR>Vern Bunch, AVR consultant and AVR designer
<HR>
 <B>peret</B> - Jan 06, 2010 - 12:11 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle>vbunch wrote:</DIV>
<DIV class=3Dquotecontent>When you have $7080 (28,800) divided by $3841 =
(14,401),=20
the correct answer is: $0001 and remainder $FFF6 (1.99986). <BR>However, =
the=20
Atmel DIV16u returns $0001 remainder $383F, quite an error. =
<BR></DIV><BR>Dude,=20
WTF? <BR><BR>Let's do this manually, by long division. <BR><BR>$3841 =
goes into=20
$7080 once. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>(hex assumed) <BR>&nbsp; &nbsp; &nbsp; ____1___ =
<BR>3841=20
) 7080 <BR>&nbsp; &nbsp; &nbsp; &nbsp;3841 - <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;----=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;383F <BR></DIV><BR>$3841 won't go into =
$383F, so=20
the quotient is 1 and the remainder is $383F. The Atmel routine returns =
the=20
correct answer. <BR><BR>The number $FFF6 might possibly occur in some =
floating=20
point representation, but can never happen in unsigned integer math, =
since it is=20
larger than the dividend.
<HR>
 <B>peret</B> - Jan 06, 2010 - 12:32 AM<BR><B>Post subject: </B>RE: Re: =
RE:=20
[DIS][ASM] Dirty Math Tricks
<HR class=3Dsep>
 Oh, I see where you got it from. <BR><BR>If you want to generate the =
fractional=20
bits, take the remainder, multiply by 16 (shift left 4) and divide this =
by the=20
divisor. Repeat until you have enough "(hexa)decimal" places. <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>&nbsp; &nbsp; &nbsp; ____1FF... <BR>3841 ) =
7080=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;3841 - <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;----=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;383F &lt;&lt;4 <BR>&nbsp; &nbsp; &nbsp;=20
&nbsp;3841 * F - <BR>&nbsp; &nbsp; &nbsp; &nbsp;---- <BR>&nbsp; &nbsp; =
&nbsp;=20
&nbsp; 3821 &lt;&lt;4 <BR>&nbsp; &nbsp; &nbsp; &nbsp; 3841 * F - =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; &nbsp;---- <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
&nbsp;3641=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... etc <BR></DIV><BR><BR>Again, =
this is=20
just confirming that the original division routine got it right. You =
didn't=20
carry out enough steps to format the answer the way you expected. =
<BR><BR>Note=20
that since the first remainder is guaranteed to be less than the =
divisor, each=20
successive step is guaranteed to produce a quotient less than 16, ie a =
single=20
hex digit. You have to manually concatenate these single digits to the =
number of=20
places you want.
<HR>
 <B>vbunch</B> - Jan 08, 2010 - 11:23 PM<BR><B>Post subject: =
</B>division
<HR class=3Dsep>
 Thank you my friends for your correct responses. It is my fault that I=20
mentioned "remainder" when I expected a fully usable result, without =
having to=20
divide again, and one that had 16 bit accuracy. So the Atmel division =
routine is=20
"correct" but unusable without more computation. Since there was no =
mention that=20
the result is unusable without further division, I niavely skipped the =
true math=20
definition of "remainder" and went right to "answer", I should not have =
done=20
that. <BR><BR>I have since written an assembly language routine that =
gives me a=20
correct (and directly usable) 16 bit division in one run, and it is less =
time=20
(156 cycles) then the published 16 bit divide routine. It took 3 weeks =
at 104=20
hours a week, and I'm way beyond tired. <IMG border=3D0 alt=3D"Very =
Happy"=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_biggr=
in.gif">
<HR>
 <B>clawson</B> - Jan 08, 2010 - 11:31 PM<BR><B>Post subject: </B>RE: =
division
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR>I have since written an assembly language =
routine=20
that gives me a correct (and directly usable) 16 bit division in one =
run, and it=20
is less time (156 cycles) then the published 16 bit divide routine. It =
took 3=20
weeks at 104 hours a week, and I'm way beyond tired <BR></DIV><BR>I =
guess it's=20
too late to say that you could have "borrowed" the source for a / =
routine from=20
an open source C compiler?
<HR>
 <B>peret</B> - Jan 08, 2010 - 11:39 PM<BR><B>Post subject: </B>RE: =
division
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>I guess it's too late to say that you could =
have=20
"borrowed" the source for a / routine from an open source C compiler?=20
</DIV><BR>Actually I suspect in this case he could not, because the =
answer he=20
wanted was in a fixed point format. He got simple integer division from =
the=20
appnote. The compiler would have given him full float, which would =
challenge me=20
to adapt to a fixed format in assembler (and I consider myself rather =
good at=20
it). <BR><BR>As a matter of interest, if we did look at the source for a =
/=20
routine in an open source C compiler - let's say, and why not, the GCC =
compiler=20
- would we be looking at assembler, or C?
<HR>
 <B>clawson</B> - Jan 08, 2010 - 11:46 PM<BR><B>Post subject: </B>RE: =
division
<HR class=3Dsep>
=20
<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent><BR>would we be looking at assembler, or C?=20
<BR></DIV><BR>Assembler. Here's a snippet from gcc/config/avr/libgcc.s: =
<BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV =
class=3Dcodecontent>/****************************************************=
***=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp;Division 16 / 16 =3D&gt; (result + =
remainder)=20
<BR>*******************************************************/ =
<BR>#define&nbsp;=20
&nbsp;r_remL&nbsp; &nbsp;r26&nbsp; &nbsp;/* remainder Low */ =
<BR>#define&nbsp;=20
&nbsp;r_remH&nbsp; &nbsp;r27&nbsp; &nbsp;/* remainder High */ <BR><BR>/* =
return:=20
remainder */ <BR>#define&nbsp; &nbsp;r_arg1L&nbsp; &nbsp;r24&nbsp; =
&nbsp;/*=20
dividend Low */ <BR>#define&nbsp; &nbsp;r_arg1H&nbsp; &nbsp;r25&nbsp; =
&nbsp;/*=20
dividend High */ <BR><BR>/* return: quotient */ <BR>#define&nbsp;=20
&nbsp;r_arg2L&nbsp; &nbsp;r22&nbsp; &nbsp;/* divisor Low */ =
<BR>#define&nbsp;=20
&nbsp;r_arg2H&nbsp; &nbsp;r23&nbsp; &nbsp;/* divisor High */ <BR>&nbsp; =
&nbsp;=20
<BR>#define&nbsp; &nbsp;r_cnt&nbsp; &nbsp;r21&nbsp; &nbsp;/* loop count =
*/=20
<BR><BR>#if defined (L_udivmodhi4) <BR>&nbsp; &nbsp;.global&nbsp;=20
&nbsp;__udivmodhi4 <BR>&nbsp; &nbsp;.func&nbsp; &nbsp;__udivmodhi4=20
<BR>__udivmodhi4: <BR>&nbsp; &nbsp;sub&nbsp; &nbsp;r_remL,r_remL =
<BR>&nbsp;=20
&nbsp;sub&nbsp; &nbsp;r_remH,r_remH&nbsp; &nbsp;; clear remainder and =
carry=20
<BR>&nbsp; &nbsp;ldi&nbsp; &nbsp;r_cnt,17&nbsp; &nbsp;; init loop =
counter=20
<BR>&nbsp; &nbsp;rjmp&nbsp; &nbsp;__udivmodhi4_ep&nbsp; &nbsp;; jump to =
entry=20
point <BR>__udivmodhi4_loop: <BR>&nbsp; &nbsp; &nbsp; &nbsp; rol&nbsp;=20
&nbsp;r_remL&nbsp; &nbsp;&nbsp; &nbsp;; shift dividend into remainder =
<BR>&nbsp;=20
&nbsp;rol&nbsp; &nbsp;r_remH <BR>&nbsp; &nbsp; &nbsp; &nbsp; cp&nbsp;=20
&nbsp;r_remL,r_arg2L&nbsp; &nbsp;; compare remainder &amp; divisor =
<BR>&nbsp;=20
&nbsp;cpc&nbsp; &nbsp;r_remH,r_arg2H <BR>&nbsp; &nbsp; &nbsp; &nbsp; =
brcs&nbsp;=20
&nbsp;__udivmodhi4_ep&nbsp; &nbsp;; remainder &lt; divisor <BR>&nbsp; =
&nbsp;=20
&nbsp; &nbsp; sub&nbsp; &nbsp;r_remL,r_arg2L&nbsp; &nbsp;; restore =
remainder=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; sbc&nbsp; &nbsp;r_remH,r_arg2H=20
<BR>__udivmodhi4_ep: <BR>&nbsp; &nbsp; &nbsp; &nbsp; rol&nbsp;=20
&nbsp;r_arg1L&nbsp; &nbsp;&nbsp; &nbsp;; shift dividend (with CARRY) =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; rol&nbsp; &nbsp;r_arg1H <BR>&nbsp; &nbsp; &nbsp; =
&nbsp;=20
dec&nbsp; &nbsp;r_cnt&nbsp; &nbsp;&nbsp; &nbsp;; decrement loop counter=20
<BR>&nbsp; &nbsp; &nbsp; &nbsp; brne&nbsp; &nbsp;__udivmodhi4_loop =
<BR>&nbsp;=20
&nbsp;com&nbsp; &nbsp;r_arg1L <BR>&nbsp; &nbsp;com&nbsp; &nbsp;r_arg1H =
<BR>;=20
div/mod results to return registers, as for the div() function =
<BR>&nbsp;=20
&nbsp;mov_l&nbsp; &nbsp;r_arg2L, r_arg1L&nbsp; &nbsp;; quotient =
<BR>&nbsp;=20
&nbsp;mov_h&nbsp; &nbsp;r_arg2H, r_arg1H <BR>&nbsp; &nbsp;mov_l&nbsp;=20
&nbsp;r_arg1L, r_remL&nbsp; &nbsp;&nbsp; &nbsp;; remainder <BR>&nbsp;=20
&nbsp;mov_h&nbsp; &nbsp;r_arg1H, r_remH <BR>&nbsp; &nbsp;ret <BR>&nbsp;=20
&nbsp;.endfunc <BR>#endif /* defined (L_udivmodhi4) */ <BR><BR>#if =
defined=20
(L_divmodhi4) <BR>&nbsp; &nbsp;.global&nbsp; &nbsp;__divmodhi4 =
<BR>&nbsp;=20
&nbsp;.func&nbsp; &nbsp;__divmodhi4 <BR>__divmodhi4: <BR>&nbsp;=20
&nbsp;.global&nbsp; &nbsp;_div <BR>_div: <BR>&nbsp; &nbsp; &nbsp; &nbsp; =

bst&nbsp; &nbsp; &nbsp;r_arg1H,7&nbsp; &nbsp;; store sign of dividend =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;__tmp_reg__,r_arg1H =
<BR>&nbsp;=20
&nbsp; &nbsp; &nbsp; eor&nbsp; &nbsp; &nbsp;__tmp_reg__,r_arg2H&nbsp; =
&nbsp;;=20
r0.7 is sign of result <BR>&nbsp; &nbsp;rcall&nbsp; =
&nbsp;__divmodhi4_neg1 ;=20
dividend negative : negate <BR>&nbsp; &nbsp;sbrc&nbsp; &nbsp;r_arg2H,7=20
<BR>&nbsp; &nbsp;rcall&nbsp; &nbsp;__divmodhi4_neg2 ; divisor negative : =
negate=20
<BR>&nbsp; &nbsp;rcall&nbsp; &nbsp;__udivmodhi4&nbsp; &nbsp;; do the =
unsigned=20
div/mod <BR>&nbsp; &nbsp;rcall&nbsp; &nbsp;__divmodhi4_neg1 ; correct =
remainder=20
sign <BR>&nbsp; &nbsp;tst&nbsp; &nbsp;__tmp_reg__ <BR>&nbsp; =
&nbsp;brpl&nbsp;=20
&nbsp;__divmodhi4_exit <BR>__divmodhi4_neg2: <BR>&nbsp; &nbsp;com&nbsp;=20
&nbsp;r_arg2H <BR>&nbsp; &nbsp;neg&nbsp; &nbsp;r_arg2L&nbsp; =
&nbsp;&nbsp;=20
&nbsp;; correct divisor/result sign <BR>&nbsp; &nbsp;sbci&nbsp;=20
&nbsp;r_arg2H,0xff <BR>__divmodhi4_exit: <BR>&nbsp; &nbsp;ret=20
<BR>__divmodhi4_neg1: <BR>&nbsp; &nbsp;brtc&nbsp; &nbsp;__divmodhi4_exit =

<BR>&nbsp; &nbsp;com&nbsp; &nbsp;r_arg1H <BR>&nbsp; &nbsp;neg&nbsp;=20
&nbsp;r_arg1L&nbsp; &nbsp;&nbsp; &nbsp;; correct dividend/remainder sign =

<BR>&nbsp; &nbsp;sbci&nbsp; &nbsp;r_arg1H,0xff <BR>&nbsp; &nbsp;ret =
<BR>&nbsp;=20
&nbsp;.endfunc <BR>#endif /* defined (L_divmodhi4) */ </DIV>
<HR>
<B>MBedder</B> - Jan 15, 2010 - 09:20 PM<BR><B>Post subject: </B>RE: =
division
<HR class=3Dsep>
 Just for fun, I have castrated <IMG border=3D0 alt=3D"Very Happy"=20
src=3D"http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_biggr=
in.gif">=20
the OP's div_10 code even further: <BR><BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent>;---------------------------------------- <BR>; =
8-bit=20
division by 10 routine. <BR>; <BR>; Input: R0 =3D dividend. <BR>; =
Output: R1 =3D=20
result =3D dividend/10. <BR>; <BR>; Registers R0 and R16 are clobbered. =
<BR>; 5=20
words/10 clocks including RET. <BR>; <BR>div10: <BR>&nbsp; =
&nbsp;ldi&nbsp;=20
&nbsp;r16,205 <BR>&nbsp; &nbsp;mul&nbsp; &nbsp;r0,r16 <BR>&nbsp; =
&nbsp;ldi&nbsp;=20
&nbsp;r16,32 <BR>&nbsp; &nbsp;mul&nbsp; &nbsp;r1,r16 <BR>&nbsp; =
&nbsp;ret=20
<BR>;---------------------------------------- <BR></DIV>
<HR>
<B>sparky23882</B> - Apr 30, 2010 - 05:07 PM<BR><B>Post subject: </B>
<HR class=3Dsep>
The OP's div_10 code was buggy at values like 19, 29, 39, ... or at 21, =
31, 41,=20
... depending on whether the correction (INC) was done or not. Here's a =
fixed=20
version, with remainder calculation (remainder lines marked, strip them =
if not=20
needed, saves 5 cycles): <BR>
<DIV class=3Dcodetitle><B>Code:</B></DIV>
<DIV class=3Dcodecontent><BR>// input: A, output/value: R1, =
output/remainder: A=20
<BR>// total cycles: 13 <BR>PUSH A&nbsp; &nbsp;&nbsp; &nbsp;//2 Me (for=20
remainder) <BR>INC A&nbsp; &nbsp;&nbsp; &nbsp;//1 Me <BR>CPI A, 0&nbsp;=20
&nbsp;//1 Me <BR>BRNE x&nbsp; &nbsp;&nbsp; &nbsp;//1,2 Me <BR>DEC =
A&nbsp;=20
&nbsp;&nbsp; &nbsp;//1 Me <BR>x:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; =
&nbsp;//0 Me=20
<BR>LDI B, 51&nbsp; &nbsp;//1 RetroDan <BR>MUL A, B&nbsp; &nbsp;//2 =
RetroDan=20
<BR>LSR R1&nbsp; &nbsp;&nbsp; &nbsp;//1 RetroDan <BR>POP A&nbsp; =
&nbsp;&nbsp;=20
&nbsp;//2 Me (for remainder) <BR>SUB A, R1&nbsp; &nbsp;//1 Me (for =
remainder)=20
<BR></DIV><BR>Hope this is useful for someone out there. <BR><BR>My =
approach:=20
<BR><BR>I made a list with values, RetroDan and RetroDan with INC. It =
looked=20
somehow like this: <BR>8 - 0 0 <BR>9 - 0 1 <BR>10 - 0 1 <BR>11 - 1 1 =
<BR><BR>So=20
one was too low, the other too high around exact matches (i.e. dividable =
by 10=20
with no remainder). So I took the one without INC (saves one cycle), =
INCreased=20
the value before giving it to the RetroDan stuff, so all results were =
accurate -=20
but "255" which becomes 0. <BR><BR>A quick check for the overflow after=20
increasing (i.e. value=3D0), decrease it again (make it 255 again, which =
gives the=20
correct result) and done. <BR><BR>P.S: I know it's an old thread, but I =
think=20
it's an important one that's read by a lot of people for finding a good=20
divide-by-10 routine.
<HR>
 <B>danni</B> - May 03, 2010 - 04:19 PM<BR><B>Post subject: </B>
<HR class=3Dsep>
But I would ask at first, whats the purpose to do a division by 10?=20
<BR><BR>Mostly it was the decimal output conversion. <BR>The fastest way =
to do=20
so, was the subtraction method, since no divison nor multiplication was =
needed.=20
<BR>A small example for 16 bit ASCII output can be seen on: <BR><BR><!-- =
m --><A=20
href=3D"http://www.avrfreaks.net/index.php?name=3DPNphpBB2&amp;file=3Dvie=
wtopic&amp;p=3D453721#453721"=20
target=3D_blank>http://www.avrfreaks.net/index.php?name=3DPNphpBB2&amp;fi=
le=3Dviewtopic&amp;p=3D453721#453721</A><!-- m -->=20
<BR><BR><BR>Peter
<HR>
 <B>Koshchi</B> - May 04, 2010 - 01:50 AM<BR><B>Post subject: </B>
<HR class=3Dsep>

<DIV class=3Dquotetitle><B>Quote:</B></DIV>
<DIV class=3Dquotecontent>The fastest way to do so, was the subtraction =
method,=20
since no divison nor multiplication was needed. </DIV>But repeated =
subtraction=20
that that routine uses <SPAN style=3D"FONT-WEIGHT: bold">is =
</SPAN>division. And=20
the multiplies when done with the hardware multiply are very fast.
<HR>
=20
<DIV align=3Dcenter>All times are GMT + 6 Hours<BR>Powered by <A=20
style=3D"TEXT-DECORATION: none" href=3D"http://www.pnphpbb.com/" =
target=3D_blank><FONT=20
color=3D#ff6600><B><I>PN</I></B></FONT><FONT=20
color=3D#0001f0><B>phpBB2</B></FONT></A>&nbsp;=C2=A9 2003-2006&nbsp;The =
PNphpBB=20
Group<BR><A=20
onclick=3D"window.open('./modules/PNphpBB2/docs/copyrite.html', =
'_pnphpbb2_credits', 'HEIGHT=3D250,WIDTH=3D450,scrollbars=3Dyes');return =
false;"=20
href=3D"http://www.avrfreaks.net/modules/PNphpBB2/docs/copyrite.html"=20
target=3D_pnphpbb2_credits>Credits</A> </DIV></BODY></HTML>

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_smile.gif

R0lGODlhDwAPALMOAP/qAEVFRQAAAP/OAP/JAP+0AP6dAP/+k//9E///////xzMzM///6//lAAAA
AAAAACH5BAEAAA4ALAAAAAAPAA8AAARb0EkZap3YVabOGRcWcAgCnIMRTEEnCCfwpqt2mHEOagoO
nz+CKnADxoKFyiHHBBCSAdOiCVg8KwPZa7sVrgJZQWI8FhB2msGgwTXTWGqCXP4WBQr4wjDDstQm
EQA7

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_biggrin.gif

R0lGODlhDwAPALMNAEVFRf/qAAAAAP/////OAP/JAP+0AP6dAP/+k//9E///x///6//lAAAAAAAA
AAAAACH5BAEAAA0ALAAAAAAPAA8AAARZsEkJap241aUQIhcGcEkSnMQBTEBnnnC6aogpwHcAasqb
B7mCCoD4wXCGSlHAbDqTANtgSh0IClACsEq9qjRaAfe6AxMYTvKXQiAU3m9ZpmKoG4YZlmU2iQAA
Ow==

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_twisted.gif

R0lGODlhDwAPAMQRAEVFRf/qAAAAAP/OAP6dAP/9E/+0AP8AAP/////+k//JAP//x/4qAJaWljMz
M/5tA///6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEA
ABEALAAAAAAPAA8AAAVrIABEpGiSkcmY0JIkgyo+RLEURaAPA/GINUBORwT0AA1AoiAg6pqx5C0g
aD6bCoJoKThUqV2BwrClHg7Es5gsvBK/Y9Eg4HASHdmRscrvx0o8AgiDgwJHKEYxfEZaKCUABpEG
WiOOiCaVKCEAOw==

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_eek.gif

R0lGODlhDwAPALMNAP///wAAAP/qAEVFRf/OAP/JAP+0AP6dAP/lAP/9E//+k///6///xwAAAAAA
AAAAACH5BAEAAA0ALAAAAAAPAA8AAARXsEk5ap241cWUIhcWjEkinGMwBUAbnALrNnILvLUr77Gr
264eMDCovVA24iCRgqFGhgrBSUUUDgPN9HksgCgEAsJpJWAng3BhvTZnMRWD3IB9ZzQWuyQCADs=

------=_NextPart_000_000D_01CB1334.48E2C780
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.avrfreaks.net/modules/PNphpBB2/images/smiles/icon_razz.gif

R0lGODlhDwAPALMOAP/qAEVFRQAAAP/OAP8AAP/JAP+0AP6dAP/9E//+k///x///6zMzM//lAAAA
AAAAACH5BAEAAA4ALAAAAAAPAA8AAARd0EkZap3Y1aVSGhcWcAgCnMMRTEEnCCfwpquWmHEOagoO
n7+CKnADxoKGSiLHBBSSAROjCWA8KwPZa7sVrgJZAWE8FhR2msGgESAHziqWutB+0zIVg94wzLAs
NRMRADs=

------=_NextPart_000_000D_01CB1334.48E2C780--
